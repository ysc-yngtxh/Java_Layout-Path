
### 什么是Hash表？
    Hash 表又叫做“散列表”，它是通过 key 直接访问在内存存储位置的数据结构， 
    在具体实现上，我们通过 hash 函数把 key 映射到表中的某个位置，来获取这个位置的数据，从而加快查找速度。


### HashMap是如何解决Hash冲突的？
    1、HashMap底层是采用数组结构来存储数据元素，数组的默认长度是16.
    2、当我们通过put方法去添加数据的时候，HashMap会根据key的hash值进行取模运算，最终把这样一个值保存到数组的指定位置。
    3、但是这样的设计方式会存在hash冲突的问题，也就是两个不同的hash值的key，取模后会落到同一个数组下标.

    所以HashMap引入了一个链式寻址法来解决hash冲突的问题，也就是说对于存在冲突的key，HashMap把这些key组成一个单向链表，
    然后采用尾插法把这样一个key保存到链表的一个尾部。

    Java8之前，HashMap的插入方法采用的是头插法，即新插入的元素会插入到链表的头部。
    并且尾插效率是不如头插，因为尾插需要通过遍历找到最后一个尾节点。
    但是头插会产生一个死链的问题：
        在并发环境下，多个线程同时put数据，利用的是头插法的话，新插入的元素会被放置在链表的头部，可能会引起链表环形问题，使得链表无法正确遍历或者出现死循环的情况。

    可参考这篇文章（关于并发下扩容导致的数据丢失和死链）：https://cloud.tencent.com/developer/article/1631902
    
    这里扩展一下：Redis 中的数据结构是类似于 HashMap 的，但是 Redis 使用的确实头插法。原因在于 Redis 是单线程的，不存在线程安全问题。

### 解决hash冲突的方法有很多
    1、链式寻址法。是一种非常常见的方法，简单理解就是把存在 hash 冲突的 key，以单向链表的方式来存储.
                 比如 HashMap 就是采用链式寻 址法来实现的。
    
    2、开放寻址法，也称为线性探测法。就是直接从冲突的数组位置向下去寻找一个空的数组下标，进行数据的存储。
                                在ThreadLocal里面有使用到这个线性探测法。
    
    3、再哈希法。如果某个hash函数产生了冲突，那么再用另外一个hash函数进行计算，一直计算直到不再产生冲突。
               这种方式会增加计算时间，性能影响较大。比如像布隆过滤器就采用了这种方法。
    
    4、建立公共溢出区。把 hash 表分为基本表和溢出表两个部分，把存在冲突的key统一放在一个公共溢出区里面进行存储。
    
    综上，HashMap 在 JDK1.8 版本中，通过链式寻址法+红黑树的方式来解决 hash 冲突问题，
    其中红黑树是为了优化 Hash 表链表过长导致时间复杂度增加的问题。
    当链表长度大于 8 并且 hash 表的容量大于等于 64 的时候，再向链表中添加元素就会触发转化。 