
## 在Java中，如果你重写了equals()方法，通常也建议你重写hashCode()方法。

    在Java中，`equals` 和 `hashCode` 方法是协同工作的，特别是在对象被用作哈希集合（如 `HashMap`, `HashSet`, `Hashtable` 等）的键时。
    这是因为哈希集合依赖于 `hashCode` 来确定对象的存储位置，并使用 `equals` 来判断两个对象是否相等。

    假设你不重写 `hashCode` 方法，它将保留从父类（通常是 `Object` 类）继承下来的行为，
    这通常意味着每个对象都有不同的 `hashCode` 值（基于对象的内存地址）。
    因此，即使两个对象按照你新定义的 `equals` 方法是相等的，它们的 `hashCode` 值仍然可能不同。
    这会导致哈希集合无法正确地识别出这两个对象是相等的，因为哈希集合首先使用 `hashCode` 来缩小搜索范围，
    然后仅对具有相同 `hashCode` 的对象使用 `equals` 进行精确比较。

    例如，在 `HashMap` 中，如果你试图将一个键值对放入其中，而该键与已经存在的键 `equals` 相等但 `hashCode` 不同，
    `HashMap` 可能会认为这是一个新的、不同的键，并将键值对作为新的条目插入，而不是更新已有的键对应的值。

    为了确保对象在哈希集合中的行为符合预期，当重写 `equals` 方法时，你也应该相应地重写 `hashCode` 方法，以保证上述约定得到遵守。

