package P16_JUC并发.JUC并发Ⅸ_关于AtomicReference非阻塞原子性读写操作;

/**
 * @author 游家纨绔
 * @dateTime 2023-08-22 18:30:00
 * @apiNote TODO
 */
public class Atomic1_CAS无锁算法 {
	/**
	 * Atomic包下的类是无锁操作，无锁的实现就得益于CAS算法
	 * 一、CAS是Compare And Swap的简称，即比较并交换的意思。CAS是一种无锁算法，其算法思想如下：
	 *    CAS的函数公式：compareAndSwap(V, E, N)
	 *        其中 V 表示要更新的变量(从主内存中读取的值)，E 表示预期值(来自于对内存位置（V）之前的读取)，N 表示期望更新的值。
	 *        调用 compareAndSwap() 函数来更新变量V，如果 V 的值等于预期值E，那么将其更新为 N；
	 *        如果 V 的值不等于期望值E，则说明有其它线程更新了这个变量，此时执行更新操作失败，
	 *        并且重新读取该变量的值再次尝试调用 compareAndSwap() 来更新。
	 *
	 *    可见CAS其实存在一个循环的过程。
	 *        1、如果有多个线程在同时修改这一个变量V，在修改之前会先拿到这个变量的值，再和变量对比看是否相等，
	 *        2、如果相等，则说明没有其它线程修改这个变量，自己更新变量即可。
	 *        3、如果发现要修改的变量和期望值不一样，则说明在读取变量V的值后，有其它线程对变量V做了修改。
	 *           那么，放弃本次更新，重新读变量V的值，并再次尝试修改，直到修改成功为止。
	 *        4、这个循环过程一般也称作 自旋
	 *
	 * 二、CAS存在的缺点（虽然通过CAS可以实现无锁同步，但是CAS也有其局限性和问题所在）
	 *   （1）只能保证一个共享变量的原子性
	 *       CAS不像 synchronized 和 ReentrantLock 一样可以保证一段代码和多个变量的同步。
	 *       对于多个共享变量操作是CAS是无法保证的，这时候必须使用枷锁来是实现。
	 *   （2）存在性能开销问题
	 *       由于CAS是一个自旋操作，如果长时间的CAS不成功会给CPU带来很大的开销。
	 *   （3）ABA问题
	 *       因为CAS是通过检查值有没有发生改变来保证原子性的，假若一个变量V的值为A，线程1和线程2同时都读取到了这个变量的值A，
	 *       此时线程1将V的值改为了B，然后又改回了A，期间线程2一直没有抢到CPU时间片。直到线程1将V的值改回A后线程2才得到执行。
	 *       那么此时，线程2并不知道V的值曾经改变过。这个问题就被成为 ABA问题 。
	 *
	 *  ABA问题的解决其实也容易处理，即添加一个版本号，更次更新值同时也更新版本号即可。
	 *     AtomicStampedReference：就是用来解决ABA问题的。
	 */
}
