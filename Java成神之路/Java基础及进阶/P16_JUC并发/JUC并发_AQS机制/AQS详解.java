package P16_JUC并发.JUC并发_AQS机制;

/**
 * @Author 游家纨绔
 * @Description TODO
 * @Date 2025-07-05 10:50:00
 */
/* AQS（AbstractQueuedSynchronizer）是一个用于构建锁和同步器的框架，它提供了一种基于队列的同步器框架。
 * 通过继承 AQS 可以实现自定义的锁和同步器，如：ReentrantLock、CountDownLatch、Semaphore等;
 *
 * 1、AQS核心思想:
 *   如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，
 *   如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。
 *   这个机制 AQS 通过 CLH等待队列锁（FIFO先进先出）来管理线程的获取和释放锁的请求，即将暂时获取不到锁的线程加入到队列中。
 *
 * 2、AQS的工作原理
 *   AQS基于一个双向链表维护的 CLH（Craig，Landin，and Hagersten）等待队列来管理线程的获取和释放锁的请求，
 *   其中，CLH队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。
 *   每一条请求共享资源的线程封装成一个CLH锁队列的一个节点（Node），节点包含线程的引用、状态信息以及指向前后节点的引用。
 *   当线程请求锁时，如果锁被其他线程持有，则将该线程加入到等待队列中；当锁被释放时，唤醒等待队列中的线程，使其重新尝试获取锁。
 *
 * 3、AQS的具体实现
 *   AQS通过使用 volatile 关键字修饰的int类型的共享状态变量 state 来表示锁的状态，保证其变量 state 的可见性。
 *   并使用 CAS（Compare-And-Swap）操作来更新状态，保证了状态的原子性。成功则说明获取锁成功；失败则进入等待队列，等待被唤醒。
 *
 * 4、AQS提供了两种获取锁的方式：
 *   独占式：只有一个线程可以获取锁，其他线程需要等待;
 *   共享式：多个线程可以同时获取锁，如读写锁;
 *
 * 5、AQS的主要方法包括：
 *   - acquire(int arg)：获取锁，arg表示获取锁的参数。
 *   - release(int arg)：释放锁，arg表示释放锁的参数。
 *   - tryAcquire(int arg)：尝试获取锁，arg表示获取锁的参数。
 *   - tryRelease(int arg)：尝试释放锁，arg表示释放锁的参数。
 *
 * 6、AQS为什么要使用 CLH 等待队列（FIFO）？
 *   公平锁：
 *      CLH 等待队列（FIFO）可以保证线程获取锁的顺序性，确保先请求锁的线程先获取锁，后请求锁的线程后获取锁。
 *      当多个线程同时请求锁时，会对获取到锁的线程进行队列检查，判断获取到锁的线程是否还存在前驱节点。
 *      如果存在前驱节点，则当前线程会被阻塞，直到前驱节点释放锁。否则，当前线程可以直接获取锁。
 *   非公平锁：
 *      则是直接通过 CAS 操作尝试获取锁，对于获取到锁的线程不会进行队列检查（不会判断获取到锁的线程是否还存在前驱节点）。
 */
public class AQS详解 { }
