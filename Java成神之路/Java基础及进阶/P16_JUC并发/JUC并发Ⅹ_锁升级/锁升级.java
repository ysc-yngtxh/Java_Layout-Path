package P16_JUC并发.JUC并发Ⅹ_锁升级;

/**
 * @author 游家纨绔
 * @dateTime 2025-02-23 22:00
 * @apiNote TODO
 */
public class 锁升级 {
    /**
     * 为了优化 synchronized锁 的效率。
     * 在 JDK 1.6 之前，synchronized 还是一个重量级锁，是一个效率比较低下的锁，
     * 但 JDK 1.6 后，JVM为了提高锁的获取与释放效率对（synchronized ）进行了优化，引入了 偏向锁 和 轻量级锁。
     * 从此以后锁的状态就有了四种（无锁 --> 偏向锁 --> 轻量级锁 --> 重量级锁）。
     * 并且四种状态会随着竞争的情况逐渐升级，也就是说只能进行锁升级（从低级别到高级别），不能锁降级（高级别到低级别）。
     * 这种 锁升级却不能降级 的策略，目的是为了提高获得锁和释放锁的效率。
     *
     * 1、无锁
     *    无锁是指对象没有被任何线程锁定的时候。
     *    但如果有线程开始竞争访问该对象的同步块时，锁的状态可能会升级。
     *    比如当第一个线程尝试获取锁时，可能会从无锁变为偏向锁，或者直接到轻量级锁，这取决于是否有竞争。
     *
     *    注意：这里的无锁是一种状态，是JVM对对象同步状态的描述。
     *         而 “无锁编程” 指通过CAS（如AtomicInteger）实现线程安全，避免传统锁机制。
     *         两者概念不同，但无锁状态为CAS操作提供了基础。
     *
     * 2、偏向锁
     *    偏向锁是指当一段同步代码（例如：synchronized代码块）只被一个线程所访问（即不存在多个线程的竞争时），
     *    该线程获得的锁对象会变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是 “偏向于第一个获得它的线程” 的锁。
     *
     *    当第一次执行完同步代码块后，线程并不会主动释放偏向锁。
     *    当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），
     *    如果是则正常往下执行，由于第一次执行完没有释放锁，往下执行也就不需要重新加锁。【这个过程可参考 锁的可重入性】
     *    如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。
     *
     *    当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。
     *    在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。
     *    轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。
     *
     *    偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。
     *
     *    关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，
     *    然后判断锁对象是否处于被锁定状态。
     *    如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。
     *
     * 3、轻量级锁（自旋锁）
     *    轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，
     *    其他线程会通过 自旋 的形式尝试获取锁，线程不会阻塞，从而提高性能。
     *
     *    轻量级锁的获取主要由两种情况：
     *    ①、当关闭偏向锁功能时；
     *    ②、由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。
     *
     *    一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。
     *    这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。
     *                           只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。
     *
     *    在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。
     *    获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。
     *    先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，比较并设置是原子性发生的。
     *    这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。
     *
     *    长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，
     *    这种现象叫做忙等（busy-waiting）。
     *    如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。
     *    这是一种折中的想法，短时间的忙等，换取线程在用户态和内核态之间切换的开销。
     *
     * 4、重量级锁
     *    重量级锁是指当有一个线程获取重量级锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。
     *
     *    对于轻量级锁中的忙等现象，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。
     *    如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。
     *    当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。
     */

	// 锁对象
	private static Object obj = new Object();

	// 可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。
	// synchronized 和 ReentrantLock 都是可重入的，可重入降低了编程复杂性
	public static void main(String[] args) {
		// 自定义Runnable对象
		Runnable runnable = () -> {
			//  使用嵌套的同步代码块，实现 synchronized 的可重入锁
			synchronized (obj) {
				System.out.println(Thread.currentThread().getName() + "第一次获取锁资源...");
				synchronized (obj) {
					System.out.println(Thread.currentThread().getName() + "第二次获取锁资源...");
					synchronized (obj) {
						System.out.println(Thread.currentThread().getName() + "第三次获取锁资源...");
					}
				}
			}
		};
		new Thread(runnable, "t1").start();
	}

}
