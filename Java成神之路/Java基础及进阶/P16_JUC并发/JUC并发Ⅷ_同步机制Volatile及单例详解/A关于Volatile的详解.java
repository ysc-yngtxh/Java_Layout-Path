package P16_JUC并发.JUC并发Ⅷ_同步机制Volatile及单例详解;

public class A关于Volatile的详解 {
    /**
     * 一、什么是JMM
     *    JMM：Java内存模型，概念！约定！
     *        Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。
     *        简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。
     *
     *        JMM 操作变量的时候不是直接在主存进行操作的，而是每个线程拥有自己的工作内存，在使用前将该变量的值copy一份到自己的工作内存,
     *        读取时直接读取自己的工作内存中的值。写入操作时，先将修改后的值写入到自己的工作内存，再将工作内存中的值刷新回主存.
     *
     *    关于JMM的一些同步的约定：
     *      1、线程执行前，必须读取主存中的最新值到工作内存中
     *      2、线程结束前，必须把共享变量立刻刷回主存
     *      3、假如两个线程同时拷贝一个变量，但是当其中一个线程修改了共享变量的值后，如果没有进行同步操作，其它线程并不会立刻感知到该变化。
     *        这是因为，其它线程看到的是自己工作内存中的旧值，并没有及时的更新到最新的主内存中的值。因此需要 Volatile 关键字来实现可见性
     *
     * 二、Volatile 是Java虚拟机提供的轻量级的同步机制
     *
     *    Java编程语言中允许线程访问共享变量。为了确保共享变量能被一致地和可靠的更新，线程必须确保它是排他性的使用此共享变量，
     * 通常都是获得对这些共享变量强制排他性的同步锁。比如：Synchronized同步锁。
     *    Synchronized 能够实现原子性和可见性，在Java内存模型中，synchronized规定，线程在加锁时，
     * 先清空工作内存 -→ 在主内存中拷贝最新变量的副本到工作内存 -→ 执行完代码 -→ 将更改后的共享变量的值刷新到主内存中 -→ 释放互斥锁。
     *    Java编程语言提供了另一种机制，volatile域变量，对于某些场景的使用这要更加的方便。
     * 可以把变量声明为volatile，让Java内存模型来保证所有线程都能看到这个变量的同一个值
     * <p>
     *     1、保证可见性（store和load指令）
     *           volatile实现内存可见性是通过 store 和 load 指令完成的；
     *           也就是对volatile变量执行写操作时，会自动在写操作后加入一条 store 指令，即强迫线程将最新的值刷新到主内存中；
     *           而在读操作时，则会自动加入一条load指令，即强迫从主内存中读入变量的值。
     *           简单来说：如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。
     *     2、不保证原子性（即无法保证操作是不可分割，可能会出现一半操作成功，一半操作失败）
     *     3、禁止指令重排
     *            你写的程序，计算机并不是按照你写得那样去执行的。
     *            指令重排：编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段
     *            源代码 --> 编译器优化的重排 --> 指令并行也可能会重排 --> 内存系统也会重排 --> 执行
     *            int x = 1;  1
     *            int y = 2;  2
     *            x = x + 5;  3
     *            y = x * x;  4
     *            我们所期望的结果是1234，但重排的是2134  1324。但不可能是4123，因为处理器再进行重排的时候，会考虑数据之间的依赖性。
     *            实现效果：可参考【B单例模式详解】中线程安全的懒汉式单例代码
     */
    static int a = 0;
    static volatile boolean flag = false;
    public static void write() {
        a = 2;
        flag = true;
    }
    public static void multiply() {
        if (flag) {
            int ret = a * a;
            System.out.println(ret);
        }
    }

	public static void main(String[] args) {
		new Thread(A关于Volatile的详解::write, "A").start();
		// 这种写法看起来很奇怪，因为Thread方法中要有Runnable接口的实现类，而这里直接写了一个方法引用
		// 其实这里是lambda方法引用，等价于 new Thread(()-> A关于Volatile的详解.write(), "A").start();
		new Thread(A关于Volatile的详解::multiply, "B").start();
		// 简单分析一下这些代码，最后会打印什么？
		// 第一感觉就是：输出为：4; 毕竟 a 赋值为 2 --> 2 * 2 可不就等于 4 嘛
		// 正确结果确实是 4; 但是如果把变量flag的关键字 volatile 去掉; 结果还会是 4 嘛？
		// 1、假如 write() 方法中 进行了指令重排 先执行 flag = true; 后执行的 a = 2;
		// 2、而此时线程 A 和线程 B 又同时执行，那么就会有可能出现线程 A 在执行write()方法中的 flag = true; 后就挂起了。
		//   此时线程 B 再去执行multiply()方法，导致最后打印输出结果就会是 0 * 0 = 0
	}

	static class Visibility {
		private volatile static int num = 0; // 保证了主存数据的可见性

		public static void add() {
			num++;
		}

		public static void main(String[] args) {
			for (int i = 1; i <= 20; i++) {
				new Thread(() -> {
					for (int j = 0; j < 1000; j++) {
						add();
					}
				}, "A").start();
			}
			while (Thread.activeCount() > 2) {
				Thread.yield();
			}
			System.out.println(Thread.currentThread().getName() + " " + num); // 结果总是小于20000,没办法保证
		}
		// 我们分析一下，为什么执行程序的结果总是小于 20000
		// 1、按理来说我们把共享变量num加上了 volatile 关键字后，每次我们去修改 num 值之前读取出来都会是最新值
		// 2、也就是说我现在有 20 条线程开始执行，由于 volatile 的可见性保证了在读取的时候总是最新值
		// 3、而我们执行的 add() 方法不是一个原子操作：
		//    ①、首先从主内存中读取到共享变量 num 最新值，并将最新值复制到自己的工作内存中;
		//    ②、然后在工作内存中将 num 自增;
		//    ③、最后将工作内存里 num 自增后的结果 刷新到主内存的共享变量 num 里
		// 4、所以可能会出现同一时间片里有多个线程去执行 add() 方法
		//    设：线程1、2同时执行，线程1执行完第②步后被挂起、线程2执行完并且把num自增后的值刷回主存，此时主存中num的值为1
		//       随后线程1的开始执行第③步，这时线程1的工作内存已经读取到共享变量 num 最新值，但是这个 num 最新值影响不了已经自增后的 num 值。
		//       所以线程1工作内存中 num 自增后的结果值1 刷新到主存 = 1。即 num++ 执行了2次，但2次都是从0变为1，主存num的值最终为1
		// 5、根据上述分析可知：两个线程执行 add()，但 num 值的结果只自增了一次。所以，程序执行结果总是小于 20000 的。
	}
}
