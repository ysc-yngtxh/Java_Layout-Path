package Q17_23种设计模式.A工厂模式;

/**
 * @Author 游家纨绔
 * @Date 2025-06-16 17:00:00
 *
 * 这里使用汽车作为示例，来说明简单工厂模式、工厂方法模式和抽象工厂模式的区别。
 *    品牌：魏牌坦克、特斯拉、小米
 *    产品等级：燃油车、纯电车、新能源
 *    产品族：轿车、SUV、超跑
 *
 * Tip：开闭原则：应用程序实体（类、模块、方法等）应该对扩展开放但对修改关闭。
 *
 * 1、简单工厂模式：简单工厂模式有一个问题就是，类的创建极度依赖工厂类（SimpleCarFactory）。
 *                如果想要拓展一个“品牌”，就必须对工厂类进行修改，这违背了开闭原则。
 * 2、工厂方法模式：该模式下想要拓展一个“品牌”，只需增加一个实现类就行了，无需去改动现成的代码。拓展性较好！
 * 3、抽象工厂模式：该模式下想要拓展一个 “品牌” 或者扩展一个 “产品族”，只需要增加合适的实现类即可。
 *                但扩展 “产品等级” 时需要修改现有的代码（CarFactory），也就违背了开闭原则。
 *                比如：添加一个新的产品等级“混合动力车”，需要修改 CarFactory 接口和所有实现类。
 *
 * 总结：
 *     简单工厂：最简单，但不支持扩展，适合简单场景
 *     工厂方法：一个抽象工厂类 + 一个抽象产品类。只关注一种产品的创建，支持扩展，符合开闭原则
 *     抽象工厂：一个抽象工厂类 + 多个抽象产品类。关注多个相关或依赖产品的创建，支持“品牌”和”产品族”扩展，但“产品等级”扩展困难。
 *
 *
 * 解决抽象工厂模式中产品等级扩展违反开闭原则的方案
 *    1、接口分离原则：将“产品等级”的接口分离成多个接口，避免一个接口承担过多职责。
 *                  例如：增加新的“产品等级”同时也增加“品牌”接口，由于接口的多实现特性，
 *                       即可保证新的具体品牌类可以选择需要的接口，而旧的具体品牌类无需修改。
 *    2、默认方法（Java 8+）：在抽象工厂接口中使用默认方法提供向后兼容
 *                  例如：如果需要增加一个新的“产品等级”，可在抽象工厂接口中添加一个默认方法，提供新的“产品等级”的默认实现，
 *                       新的具体品牌类可以重写该默认方法实现新的“产品等级”，而旧的具体品牌类可选择使用也可选择不使用其默认方法，
 *                       关键是旧的具体品牌类无需进行任何修改。
 */
