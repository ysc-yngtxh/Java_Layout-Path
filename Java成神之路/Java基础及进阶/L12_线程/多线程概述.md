## 1、什么是进程？什么是线程？
<figure>

  > 进程是一个应用程序（1个进程是一个软件）  
  > 线程是一个进程中的执行场景/执行单元  
  > 一个进程可以启动多个线程
</figure>

## 2、对于Java程序来说，当在DOS命令窗口中输入：java HelloWorld
<figure>

  > 回车之后，会先启动JVM，而JVM就是一个进程  
  > JVM再启动一个主线程调用main方法  
  > 同时再启动一个垃圾回收线程负责看护，回收垃圾  
  > 最起码，现在的Java程序中至少有两个线程并发  
  > 一个是垃圾回收线程，一个是执行main方法的主线程  
  > 
  >     Java中之所以有多线程机制，目的就是为了提高程序的处理效率
</figure>

## 3、程序运行多线程详解：
<figure>

  > 使用了多线程机制之后，main方法结束只是主线程结束了，主栈空了，其他的栈可能还在压栈弹栈。  
  > main方法与其他方法共用一个堆和方法区，但是栈是分开压栈弹栈的。
</figure>

## 4、分析一个问题：对于单核的CPU来说，真的可以做到真正的多线程并发吗?
<figure>

    对于多核的CPU电脑来说，真正的多线程并发是没问题的，4核CPU表示同一个时间点上，可以真正的有4个进程并发执行

    对于单核的CPU来说，在某个时间点上实际上只能处理一件事情。
    但是由于CPU的处理速度极快，多个线程之间频繁切换执行，给人的感觉像是多个事情同时在做
</figure>

## 5、线程的生命周期和状态
<figure>

    1.1 新建状态（New）
        • 线程对象已经被创建，但尚未开始执行。此时，线程尚未被加入到线程调度队列。
        • 通过 Thread 类的构造方法创建线程对象后，线程进入此状态。
          Thread thread = new Thread();
          此时，线程并没有启动，也没有执行任何代码。

    1.2 就绪状态（Runnable）
        • 当线程对象调用了 start() 方法，线程进入就绪状态。线程已经准备好执行，等待 CPU 调度。
        • 注意：就绪状态并不意味着线程正在执行，它只是表示线程已准备好，处于线程池或者线程调度队列中，等待操作系统分配CPU时间片。
          Thread thread = new Thread();
          thread.start();  // 线程进入就绪状态

    1.3 运行状态（Running）
        • 线程在获得 CPU 时间片后开始执行，进入运行状态。此时，线程执行其 run() 方法中的代码。
        • 线程可以通过 yield() 方法主动释放 CPU 资源，或者通过阻塞操作（如 sleep()）暂时暂停执行，进入其他状态。

    1.4 阻塞状态（Blocked）
        • 线程在运行过程中遇到某些阻塞条件时，会进入阻塞状态。阻塞状态意味着线程无法继续执行，必须等待某些条件满足后才能恢复执行。
        • 常见的阻塞原因：
        •             等待锁：线程在请求一个已经被其他线程持有的锁时，会进入阻塞状态。
        •             I/O 操作：线程可能会因为等待输入/输出操作完成而阻塞。

    1.5 等待状态（Waiting）
        • 线程在执行过程中可能会因为调用 wait()、join() 或 sleep() 等方法而进入等待状态。
        • 进入等待状态的线程需要其他线程显式地通知（如调用 notify()、notifyAll()）或中断，才能恢复执行。
          synchronized (obj) {
            obj.wait();  // 线程进入等待状态
          }

    1.6 超时等待状态（Timed Waiting）
        • 线程在某些情况下会在指定的时间内等待。例如，线程调用 sleep() 或 join() 方法时，可以指定等待的时间，线程在等待期间处于超时等待状态。
          Thread.sleep(1000);  // 线程进入超时等待状态，等待 1 秒后自动恢复

    1.7 死亡状态（Terminated）
        • 当线程的 run() 方法执行完成，或者线程因异常或错误终止时，线程进入死亡状态。
        • 进入死亡状态后，线程无法再重新启动。
          Thread thread = new Thread(() -> System.out.println("线程结束"));
          thread.start();  // 执行结束后，线程进入死亡状态
</figure>

## 6、关于多线程并发环境下，数据的安全问题
<figure>

    1、以后在开发中，我们的项目都是运行在服务器当中，而服务器已经将线程的定义、线程对象的创建、线程的启动等，都已经实现完了。这些代码我们都不需要编写。

       最重要的是：你要知道，你编写的程序需要放到一个多线程的环境下运行，你更需要关注的是这些数据在多线程并发的环境下是否安全的

    2、什么时候数据在多线程并发的环境下会存在安全问题？
        三个条件：
              条件一：多线程并发
              条件二：有共享数据
              条件三：共享数据有修改行为
           满足以上三个条件之后，就会存在线程安全问题

    3、怎么解决线程安全问题呢？
         当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题，怎么解决这个问题？
              线程排队执行。（不能并发）
              用排队执行解决线程安全问题
              这种机制被称为：线程同步机制

              专业术语叫做：线程同步，实际上就是线程不能并发了，线程必须排队执行

        怎么解决线程安全问题?
            使用“线程同步机制”

         线程同步就是线程排队了，线程排队了就会牺牲一部分效率，没办法，数据安全第一位，只有数据安全了，我们才可以谈效率。
         数据不安全，没有效率的事儿了。

     4、说到线程同步这一块儿，涉及到这两个专业术语
         异步编程模型：
              线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1
              谁也不需要等谁，这种编程模型叫做：异步编程模型
              其实就是：多线程并发（效率较高）

              异步就是并发

         同步编程模型：
              线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行结束
              或者说在t2线程执行的时候，必须等待t1线程执行结束，
              两个线程之间发生了等待关系，这就是同步编程模型
              效率较低，线程排队执行

              同步就是排队

     5、Java中有三大变量：
           实例变量：在堆中
           静态变量：在方法区
           局部变量：在栈中

        以上三大变量中：
           局部变量永远不会存在线程安全问题，因为局部变量不共享（一个线程一个栈）。局部变量在栈中，所以局部变量永远都不会共享。
           实例变量在堆中，堆只有一个。静态变量在方法区中，方法区只有一个。堆和方法区都是多线程共享的，所以可能存在线程安全问题。

       局部变量+常量：不会有线程安全问题
          第一种：同步代码块
                灵活
       成员变量：可能会有线程安全问题（实例变量和静态变量都是成员变量）

     6、总结：
        synchronized有三种写法：
             第一种：
                  synchronized(线程共享对象){
                       同步代码块
                  }
   
             第二种：在实例方法上使用synchronized表示共享对象一定是this，并且同步代码块是整个方法体
   
             第三种：在静态方法上使用synchronized表示找类锁。类锁永远只有一把。就算创建了100个对象，那类锁也只有一把
   
             对象锁：1个对象1把锁，100个对象100把锁
             类锁：在静态方法上使用synchronized是类锁。不管创建了几个对象，类锁只有一把

     7、聊一聊，我们在以后开发中应该怎么解决线程安全问题？

        是一上来就选择线程同步吗？
            不是，synchronized会让程序的执行效率降低，用户体验不好，
            系统的用户吞吐量降低，用户体验差。在不得已的情况下再选择线程同步机制

        第一种方案：尽量使用局部变量代替“实例变量和静态变量”

        第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样实例变量的内存就不共享了。
                  （一个线程对应1个对象，100线程对应100个对象，对象不共享，就没有数据安全问题了）

        第三种方案：如果不能使用局部变量，对象也不能创建多个，这个时候就只能选择synchronized了。线程同步机制。
   
     8、多线程中提供的方法会不会释放锁。
        1、sleep() 方法不会释放锁
        2、yield() 方法不会释放锁
           yield() 不会让线程进入阻塞状态，而是进入就绪状态。
           如果当前线程持有锁并调用 yield()，它不会释放锁。
           因此，即使当前线程让出 CPU，其他试图获取该锁的线程仍然会被阻塞，直到当前线程释放锁。
        3、notify() 方法不会释放锁
        4、notifyAll() 方法不会释放锁
        5、interrupt() 方法不会释放锁
        
        1、wait() 方法会释放锁
           使当前线程进入等待状态，并释放持有的锁。
        2、join() 方法会释放锁
           当线程 A 调用线程 B 的 join() 方法时，线程 A 会进入阻塞状态，直到线程 B 执行完毕。所以是需要释放锁操作的。
</figure>
