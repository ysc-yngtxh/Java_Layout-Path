package M13_反射.反射Ⅵ_JDBC时候要用的只执行静态代码块;

/*
 * 研究一下：Class.forName()发生了什么？
 *    记住，重点：
 *      如果你只希望一个类的静态代码块执行，其他代码一律不执行
 *      你可以使用：
 *          Class.forName("完整类名", true, null);
 *      这个方法的执行会导致类加载和初始化。初始化时，静态代码块会执行
 *
 *      提示：
 *          后面JDBC技术时候我们要用
 */
public class 反射16_只执行静态代码块 {
    public static void main(String[] args) {
        try {
            // Class.forName(String name, boolean initialize, ClassLoader loader);
            // name表示的是类的全名；initialize表示是否初始化类；loader表示载入时使用的类载入器。
            // 第二个参数为true，那么该方法不仅会加载类，还会初始化类。意味着静态字段会被设置，静态初始化块也会被执行。
            // 第二个参数为false，该方法只会加载类，并不会初始化它。静态字段不会被设置，静态初始化块也不会被执行。
            // 第三个参数为加载器，通常为null。表示使用当前的类加载器。

            // Class.forName()方法相当于Class.forName("**", true, null); 即第二个参数默认为true
            Class.forName("M13_反射.反射Ⅵ_JDBC时候要用的只执行静态代码块.MyClass");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    /**
     * 反射到这儿也就差不多结束了，回顾完之后，不知道你有没有感觉到疑惑。
     * 就是通过反射去 修改字段、执行实例方法、构造方法...等，最后还是需要类对象的参与。
     * 既然如此，我直接使用对象的方式调用不就可以了嘛，为什么还要有反射这个机制呢？
     *
     * 其实反射更适合于那种无法new对象的类，有的类是我们在编写程序的时候无法使用new一个对象来实例化对象的
     * 比如：构造方法是私有的类；或者抽象父类，接口等无法实例化对象的类
     *      注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。
     *      动态代理 - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。
     */
}
