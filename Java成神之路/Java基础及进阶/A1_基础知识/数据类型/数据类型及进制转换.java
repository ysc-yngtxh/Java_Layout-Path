package A1_基础知识.数据类型;

/*
 * 关于Java中的数据类型
 *    1、数据类型的作用是什么？
 *           程序当中有很多数据，每一个数据都是有相关类型的，不同数据类型的数据占用的空间大小不同
 *           数据类型的作用是指导jvm在运行程序的时候给该数据分配多大的内存空间
 *    2、Java中的数据类型包括两种：
 *           基本数据类型
 *           引用数据类型
 *    3、关于基本数据类型：
 *           基本数据类型包括四大类八小种
 *             -第一类：整数型
 *                     byte, short, int, long
 *             -第二类：浮点型
 *                     float, double
 *             -第三类：布尔型
 *                     boolean
 *             -第四类：字符型
 *                     char
 *    4、字符串"abc"不属于基本数据类型，属于引用数据类型。字符属于基本数据类型。
 *    5、八种基本数据类型各自占用空间大小是多少
 *               基本数据类型    占用空间大小【单位：字节】        取值范围                默认值
 *        ----------------------------------------------------------------------------------------
 *                 byte                 1                 【-128~127】                0
 *                 short                2               【-32768~32767】              0
 *                 int                  4           【-2147483648~2147483647】        0
 *                 long                 8                                            0
 *                 float                4                 小数位6～7位                 0
 *                 double               8                 小数位15位                   0
 *                 boolean              1                【true, false】            false
 *                 char                 2                  【0~65535】              \u0000
 *
 *     6、计算机在任何情况下都只能识别二进制
 *
 *     7、什么是二进制？
 *         例如：        十进制
 *               0 1 2 3 4 5 6 7 8 9 10...
 *                      二进制
 *               0 1 10 11 100 101 110 111 1000 1001
 *                      十六进制：每十六位数进一位
 *               0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20
 *                      八进制：每八位进一位
 *               0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20
 *
 *     8、字节(byte)
 *          1 Byte = 8 bit 【1个字节=8个比特位】一个比特位表示一个二进制位：1或0
 *          1 KB   = 1024 Byte
 *          1 MB   = 1024 KB
 *          1 GB   = 1024 MB
 *          1 TB   = 1024 GB
 *
 *     9、整数型当中的byte类型，占用一个字节，所以byte类型的数据占用8个比特位。
 *               那么byte类型的取值范围是多少？
 *          关于Java中的数字类型，数字都是有正负之分的，
 *                        所以在数字的二进制当中有一个二进制位被称为"符号位"。
 *                        并且这个"符号位"在所有的二进制位的最左边，0表示正数，1表示负数。第一个数字即表示正负，又参与内存计算
 *          byte类型最大值：01111111
 *                       【01111111 = 10000000-1 = 2^7-1 = 127】
 *          byte类型的最小值：-128【具体的怎么用二进制表示，这个和原码，反码，补码有关】
 *          byte类型取值范围：【-128 ~ 127】
 *          byte类型可以表示256个不同的数字【256个不同的二进制】
 *
 *     10、二进制和十进制的转换规则：
 *            十进制转二进制
 *                2 |     97                  ...  1            /|\
 *                  |-----------                               / | \
 *                  2 |   48                  ...  0             |
 *                    |---------                                 |
 *                     2 |  24                ...  0             |
 *                       |------                                 |
 *                       2  | 12              ...  0             |   所以十进制的数字97转换为二进制结果为1100001.
 *                          |------                              |
 *                          2  |  6           ...  0             |
 *                             |------                           |
 *                              2  | 3        ...  1             |
 *                                 |------                       |
 *                                   2 |  1   ...  1             |
 *                                     |------                   |
 *                                         0
 *
 *     11、计算机只认识二进制，那么计算机是怎么表示现实世界当中的文字的呢？
 *            为了让计算机可以表示现实世界当中的文字，我们需要进行人为的干涉，
 *                      需要人负责提前制定好“文字”和“二进制”之间的对照关系。
 *                      这种对照转换关系被称为：字符编码。
 *            计算机最初只支持英文，最先出现的字符编码是：ASCⅡ码
 *                'a'--> 97【01100001】
 *                'A'--> 65
 *                '0'--> 48（是零不是字母O）
 *            面试官问你，你是怎么理解字符编码的？
 *                     【字符编码人为地干涉的定义的一本字典，对照表。在这张对照表中非常清楚的描述文字和二进制之间的关系】
 *            Java语言采用的是哪一种编码方式呢？
 *               Java语言源代码采用的是unicode编码方式，所以“常识”可以用中文。
 */
public class 数据类型及进制转换{
	static int j;              // 成员变量，没赋值
	public static void main(String[] args) {
		System.out.println(j); // 初始化发现"j"没赋值，如果是局部变量就会出错，但成员变量会输出int默认值.即结果为0.
		char c = '\u0000';     // \u0000是char的默认值
		System.out.println(c); // c的值应该是什么都没有的


		// 我们十进制是逢十进一，而二进制是（逢二进一）
		//         0  0  1  1                   0  0  1  1
		//     +   0  0  0  1               -   0  0  0  1
		//       --------------               --------------
		//         0  1  0  0                   0  0  1  0
		// 在计算机中，数字通常使用二进制表示。但是，由于二进制数只能表示非负数，所以无法直接使用二进制表示负数。
		// 为了解决这个问题，计算机使用了一种叫做【补码】的方法来表示负数。

		// 对于正数：
		//        反码、补码都与原码一样。
		// 对于负数：
		//        反码：原码中除去符号位，其他的数值位按位取反，即0变1，1变0
		//        补码：反码+1
		//
		//     补码是一种将负数转换为二进制的方法，它可以确保所有数的补码都可以使用二进制进行加法运算。
		//     原码：1111 1001
		//     反码：0000 0110（反码是将原码中的 1变为0，0变为1）
		//     补码：0000 0111（补码就是将反码进行加1操作）

		// 综上所述：正整数的运算原码与补码相同，负整数参与的运算使用【补码】进行运算。
		//         例如：-1 + 1 = 0
		//              -1的原码：1000 0001             1的原码：0000 0001
		//              -1的反码：1111 1110             1的反码：0000 0001
		//              -1的补码：1111 1111             1的补码：0000 0001
		//              -1的补码+1：1111 1111 + 0000 0001 = 0000 0000
		//         对于计算机来说：十进制转换为二进制的时候，负数的二进制是负数的补码表示。

		// 1、&（按位与）：如果两位都是1，那么结果是1，否则结果是0。
		int a1 = 60;     // 0011 1100 = 0+0+2²+2³ +2⁴+2⁵+0 = 0+0+4+8 +16+32+0 = 60
		int b1 = 13;     // 0000 1101 = 2⁰+0+2²+2³ +0+0+0  = 1+0+4+8 +0+0+0   = 13
		System.out.printf("&（按位与）计算结果：%s%n", (a1 & b1)); // 0000 1100 = 0+0+4+8 +0+0+0 = 12

		// 2、|（按位或）：如果两位至少有一位是1，那么结果是1。
		int a2 = 60;     // 0011 1100 = 0+0+2²+2³ +2⁴+2⁵+0 = 0+0+4+8 +16+32+0 = 60
		int b2 = 13;     // 0000 1101 = 2⁰+0+2²+2³ +0+0+0  = 1+0+4+8 +0+0+0   = 13
		System.out.printf("|（按位或）计算结果：%s%n", (a2 | b2)); // 0011 1101 = 1+0+4+8 +16+32+0 = 61

		// 3、^（按位异或）：如果两位是不同的，那么结果是1。
		int a3 = 60;     // 0011 1100 = 0+0+2²+2³ +2⁴+2⁵+0 = 0+0+4+8 +16+32+0 = 60
		int b3 = 13;     // 0000 1101 = 2⁰+0+2²+2³ +0+0+0  = 1+0+4+8 +0+0+0   = 13
		System.out.printf("^（按位异或）计算结果：%s%n", (a3 ^ a3)); // 0000 0000 = 0+0+0+0 +0+0+0 = 0
		System.out.printf("^（按位异或）计算结果：%s%n", (a3 ^ 0));  // 0011 1100 = 0+0+4+8 +16+32+0 = 60
		System.out.printf("^（按位异或）计算结果：%s%n", (a3 ^ b3)); // 0011 0001 = 1+0+0+0 +16+32+0 = 49

		// 4、~（按位取反）：对二进制中的每一位进行取反操作，如果原来是0，就变为1，如果原来是1，就变为0。
		System.out.printf("~（按位取反）计算结果：%s%n", ~6);
		// 值6的二进制表示是 0000 0110，~6表示取反二进制得到 1111 1001。
		//    原码：1111 1001
		//    反码：0000 0110
		//    补码：0000 0111
		// ~6的补码对应的十进制是7，加上负号符号，结果为-7

		// 5、<<和>>（左移和右移）：左移是将数字的二进制表示向左移动指定的位数，右移是将数字的二进制表示向右移动指定的位数。
		//    移位后的空位将被填充为0。左移和右移的操作结果可能依赖于所操作数的符号，对于无符号数，它们都是非负的。
		int a4 = 6;                                  // 6 = 0000 0110
		System.out.printf("<<（左移）计算结果：%s%n", (a4 << 2)); // 结果是 24，6的比特位整体左移2位得到 0001 1000，对应十进制24。
		System.out.printf(">>（右移）计算结果：%s%n", (a4 >> 2)); // 结果是 1， 6的比特位整体右移2位得到 0000 0001，对应十进制1。
		// 注意：Java中的右移运算符>>对负数进行操作时会保留符号位，即使移动的位数大于该数能表示的最大位数。
		// 例如：对于一个8位的byte类型数值，如果对其进行超过8位的右移，那么结果将是负数。
		// 6、Java二进制中使用补码来表示负数进行运算
		//   -1     --> 原码：1000 0000 0000 0000 0000 0000 0000 0001
		//              反码：1111 1111 1111 1111 1111 1111 1111 1110
		//              补码：1111 1111 1111 1111 1111 1111 1111 1111
		//   -1<<12 将负数左移12位，用负数做运算应该使用补码
		//          -1的补码：1111 1111 1111 1111 1111 1111 1111 1111
		//        -1<<12补码：1111 1111 1111 1111 1111 0000 0000 0000
		//              反码：1111 1111 1111 1111 1110 1111 1111 1111
		//              原码：1000 0000 0000 0000 0001 0000 0000 0000 --> -(2^12)=-4096
		//   ~(-1<<12) 将负数取反，也就是将负数的补码取反成为正数，正数的反码、补码都与原码一样，因此取反后就是为结果的原码
		//        -1<<12补码：1111 1111 1111 1111 1111 0000 0000 0000
		//              原码：0000 0000 0000 0000 0000 1111 1111 1111 --> (2^12)+(2^11)+...+1=4095
		int a5 = -1;
		System.out.printf("负数左移计算结果：%s%n", a5 << 12);
		System.out.printf("负数左移后取反计算结果：%s%n", ~(a5 << 12));

		// TODO 综上可发现
		//      使用异或^运算符可有效解决一些算法问题。例如：两个相同数字异或的结果为0；0异或任何数字的结果为该数字本身。
	}
}
