## 一、类加载过程

    1. 什么是类的加载过程
        一个Java文件从编码完成到最终运行，一般会经历两个阶段：编译期、运行期。
        编译，即通过javac命令，将Java文件转化为二进制字节码文件，即.class文件；
        运行，则是将.class文件交给JVM执行。
        而类加载过程就是将.class文件中类的元信息加载进内存，创建Class对象并进行解析、初始化类变量等的过程
        JVM并不是一开始就会将所有的类加载到内存，而是用到某个类，才会去加载，只加载一次，后续会说到类的加载时机

    2. 类加载详解
            类加载分为三个部分：加载、连接、初始化

        1)、加载
              类的加载主要的职责为将.class文件的二进制字节流读入内存(JDK1.7及之前为JVM内存，JDK1.8及之后为本地内存)，
              并在堆内存中为之创建Class对象，作为.class进入内存后的数据的访问入口。在这里只是读入二进制字节流，
              后续的验证阶段就是要拿二进制字节流来验证.class文件，验证通过，才会将.class文件转为运行时数据结构

        2)、连接
            类的连接分为三个阶段：验证、准备、解析。
            验证：该阶段主要是为了保证加载进来的字节流符合JVM的规范，不会对JVM有安全性问题。其中有对元数据的验证，
                 例如检查类是否继承了被final修饰的类；还有对符号引用的验证，
                 例如校验符号引用是否可以通过全限定名找到，或者是检查符号引用的权限(private、public)是否符合语法规定等。
            准备：准备阶段的主要任务是为类的静态变量开辟空间并赋默认值。
                  [1]、静态变量是基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0
                  [2]、静态变量是引用类型的，默认值为null
                  [3]、常量默认值为声明时设定的值
                       例如：public static final int i = 3; 在准备阶段，i的值即为3
            解析：该阶段的主要职责为将Class在常量池中的符号引用转变为直接引用。
                 因为这里类的信息已经被加载到内存了，所以这里会把原来通过全限定名引用的对象替换成对象内存的实际地址。
                 符号引用即字符串，说白了可以是一个字段名，或者一个方法名；直接引用即偏移量，说白了就是类的元信息位于内存的地址串，
                 例如，一个类的方法为test()，则符号引用即为test，这个方法存在于内存中的地址假设为0x123456，则这个地址则为直接引用。

        3)、初始化
            该阶段主要是对类中的静态变量赋值和静态代码块执行初始化。
            如果存在父类，那么按照顺序加载：父类静态代码块 ——> 本类静态代码块
            静态变量初始化有两种方式：
                [1]、在声明静态变量时，直接给变量赋值
                [2]、在静态代码块中为类变量赋值
                  public class Main {
                     // 静态代码块 和 静态属性 的初始化调用优先级一样，谁书写在前谁先执行。
                     static {  a = 2; }
                     static int a = 1;
                     public static void main(String[] args) {
                       System.out.println("a = "+a); // 输出 a = 1
                     }
                  }

    3. 类的加载时机(包括加载、连接、初始化)
        1、创建该类的实例
        2、调用该类的类方法
        3、访问类或接口的类变量，或为类变量赋值
        4、利用反射Class.forName(String name, boolean initialize, ClassLoader loader);
           当使用ClassLoader类的loadClass()方法来加载类时，该类只进行加载阶段，而不会经历初始化阶段，
           只有第二个参数为true时，才会去进行初始化。
           使用Class类的静态方法forName("**")，第二个参数initialize默认为true，强制初始化
        5、初始化该类的子类
        6、运行main方法，main方法所在类会被加载

## 二、类实例化过程（new）

    1、前提：.class文件已经被加载完毕（经过加载、解析和初始化）

    2、系统赋初值：给对象分配空间，对非静态成员变量属性按类型进行默认初始化（8种基本数据类型均按照默认方式初始化，其他数据类型默认为null）

    3、初始化父类成员变量的属性赋值 和 父类构造(普通)代码块。两者执行优先级一样，谁书写在前谁先执行。

    4、初始化父类构造方法

    5、初始化本类成员变量属性赋值 和 本类构造(普通)代码块。两者执行优先级一样，谁书写在前谁先执行。

    6、初始化本类构造方法

    类的加载机制和实例化的区别：
                           类的加载机制                                 类的实例化	
    定义：       把类从.class文件加载到虚拟机，为实例化做准备        创建一个类的实例(对象)的过程
    执行次数：            一个类只会执行1次                            一个类可执行多次

    ***** 常问问题：一个实例变量在对象初始化的过程中最多会被赋值几次？*****
         我们知道，JVM在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个时候实例变量被第一次赋值。
         如果我们在声明实例变量x的同时对其进行了赋值操作，那么这个时候，这个实例变量就被第二次赋值了。
         如果我们在构造代码块中，又对变量x做了初始化操作，那么这个时候，这个实例变量就被第三次赋值了。
         如果我们在构造函数中，也对变量x做了初始化操作，那么这个时候，变量x就被第四次赋值。
         也就是说，在Java的对象初始化过程中，一个实例变量最多可以被初始化4次。

## 三、类默认加载的内容顺序（忽略父类初始化部分）

     印象中往往是当new一个对象时，默认会首先加载其构造方法，事实上构造方法的加载顺序级别是最低的，具体加载顺序如下：
       （1）静态代码块 和 静态属性 的初始化。（类加载过程）
            静态代码块 和 静态属性 的初始化调用优先级一样，当两者碰在一起时，则按照代码的定义位置顺序执行，谁书写在前谁先执行。
       
       （2）构造(普通)代码块 和 普通属性 的初始化。（类实例化过程）
            构造(普通)代码块 和 普通属性 的初始化的优先级一样，当两者碰在一起时，则按照代码的定义位置顺序执行，谁书写在前谁先执行。
       
       （3）构造方法

## 四、Bean实例化流程的主要步骤：

     1）Bean定义加载：
                当Spring容器启动时，它会加载配置文件中定义的Bean，通常是通过XML配置文件、注解或者Java配置类。
                Bean的定义包含了Bean的类型、作用域、依赖关系、初始化方法、销毁方法等元数据信息。
     2）Bean的解析：
                Spring容器解析Bean的定义，将其转换为内部的Bean定义对象（如BeanDefinition）。
                该实例保存了bean对象创建必要的信息，比如bean的class类型，是否是抽象类、属性信息等。
                这个过程中，Spring会解析Bean的作用域、依赖关系等。
     3）单例Bean的实例化：
                对于单例Bean，Spring容器只创建一个实例。
                Spring首先检查Bean是否在缓存中存在，如果存在则直接返回该Bean实例（这是为了支持循环依赖的解决）。
                如果Bean不在缓存中，Spring会创建Bean的实例。这通常通过反射调用Bean类的无参构造方法完成。
     4）依赖注入：
                在Bean实例化后，Spring容器负责将Bean之间的依赖关系注入到Bean中。
                这包括根据Bean的定义，将其他Bean的引用、基本类型、集合等注入到当前Bean中。
                Spring支持多种注入方式，包括构造函数注入、setter方法注入、字段注入[注解注入]（如@Autowired）。
                除了构造注入外，其他诸如方式都是通过Jdk的反射，将属性注入到当前Bean中。
     5）Bean的初始化：
                在所有依赖注入完成后，Spring会调用Bean的初始化方法。
                这可以是通过配置文件指定的<bean init-method="..."/>，或者通过注解@PostConstruct指定的方法。
                如果Bean实现了InitializingBean接口，Spring还会调用其afterPropertiesSet()方法。
     6）Bean的后处理：
                在Bean初始化完成后，Spring容器会调用所有注册的BeanPostProcessor的postProcessAfterInitialization方法。
                这允许用户对Bean进行额外的处理或修改。
     7）Bean的使用：
                完成以上步骤后，Bean就可以被应用程序使用了。
                应用程序可以通过Spring容器获取Bean的引用，并调用其方法。
     8）Bean的生命周期管理：
                Spring容器还负责管理Bean的生命周期。
                对于实现了DisposableBean接口的Bean，Spring会调用其destroy()方法。
                如果Bean的配置中指定了<bean destroy-method="..."/>，Spring也会调用指定的销毁方法。

     需要注意的是，上述流程主要适用于单例Bean。对于原型Bean（prototype scope），每次请求时都会创建一个新的实例，
     因此不会有缓存中的Bean实例，且不会进行单例Bean特有的生命周期管理。
