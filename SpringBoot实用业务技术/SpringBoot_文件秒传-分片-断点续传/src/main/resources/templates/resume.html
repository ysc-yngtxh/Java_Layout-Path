<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>File Upload Demo</title></head>
<body>

<input type="file" id="fileInput" multiple>
<button type="button" onclick="uploadFile()">上传</button>
<div id="progressBar"></div>

<script type="text/javascript" src="/js/crypto.js"></script>
<script type="text/javascript" src="/js/encrypt.js"></script>
<script type="text/javascript">
    let file;             // 文件对象
    let fileName = null;  // 文件名
    let fileId = "";      // 文件唯一标识
    let fileChunkSize;    // 文件分片总数量
    let fileHashMd5 = 0;  // 文件的MD5值
    let isFileExist = false;     // 文件是否已经存在
    const chunkSize = 1024 * 10; // 每个分片的大小10KB

    // 响应【上传】按钮点击事件
    async function uploadFile() {
        let fileInput = document.getElementById('fileInput');
        file = fileInput.files[0];
        fileName = fileInput.files[0].name;
        // 计算整个文件的 MD5值，用于传给后端进行文件库查询，判断文件是否已经存在。
        await calculateMD5(file).then(async fileMD5 => {
            // 发送请求给后端，判断文件是否已经存在（秒传逻辑）
            await checkFileExist(fileMD5);
        })
        // 如果文件不存在，则开始分片上传
        if (!isFileExist) {
            // 由于 shardingFileDown() 是异步函数，所以在进行调用的时候要么加上 await关键字，
            // 要么通过 .then() 和 .catch() 方法来处理返回的 Promise
            // 示例：await shardingFileDown();
            shardingFileDown().then(() => {console.log('开始上传分片文件！')});
        }
    }

    // 检验该文件是否在服务器中存在
    async function checkFileExist(fileMD5) {
        return new Promise((resolve, reject) => {
            const formData = new FormData();
            formData.append('fileHash', fileMD5);
            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/file2/isTeleportation', true);
            xhr.onload = () => {
                if (xhr.status === 200) {
                    isFileExist = (xhr.responseText === 'true')
                    console.log(isFileExist ? '文件已存在，感受秒传！' : '文件不存在，开始上传！');
                    if (isFileExist) return new Promise(() => {
                    });
                    fileHashMd5 = fileMD5;
                    resolve();
                } else {
                    console.log('文件校验出错了！！！');
                    reject();
                }
            };
            xhr.send(formData);
        })
    }

    // 分片上传文件
    async function shardingFileDown() {
        fileChunkSize = Math.ceil(file.size / chunkSize);
        for (let i = 0; i < fileChunkSize; i++) {
            try {
                await uploadChunk(file, i);
            } catch (error) {
                console.error('Failed to upload chunk', i, error);
                // 如果上传失败，则尝试恢复上传
                try {
                    await uploadChunk(file, i);
                } catch (error) {
                    console.error('Failed to resume upload', i, error);
                    return;
                }
            }
        }
        // 合并文件
        try {
            const fileUrl = await mergeFile();
            console.log('File URL:', fileUrl);
        } catch (error) {
            console.error('Failed to merge file', error);
        }
    }

    function uploadChunk(file, chunkIndex) {
        return new Promise((resolve, reject) => {
            let fileTemp = file.slice(chunkIndex * chunkSize, (chunkIndex + 1) * chunkSize);
            fileTemp.fileName = fileName;
            // 计算分片文件的 MD5值，用于传给后端进行文件库查询，判断文件是否已经存在。
            let fileTempMD5 = calculateMD5(fileTemp);
            fileTempMD5.then(chunkMD5 => {
                const formData = new FormData();
                // 注意⚠️：后端想要获取分片文件的文件名只能传过去
                formData.append('chunk', fileTemp, fileTemp.fileName);
                formData.append('chunkIndex', chunkIndex);
                formData.append('chunkMD5', chunkMD5);
                formData.append('fileId', fileId);
                const xhr = new XMLHttpRequest();
                xhr.open('POST', '/file2/upload', true);
                xhr.onload = () => {
                    if (xhr.status === 200) {
                        resolve(xhr.response);
                        fileId = xhr.responseText
                    } else {
                        reject(xhr.statusText);
                    }
                };
                xhr.onerror = () => {
                    reject(xhr.statusText);
                };
                xhr.send(formData);
            })
        });
    }

    function mergeFile() {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            const formData = new FormData();
            formData.append('fileId', fileId);
            formData.append('fileName', fileName);
            formData.append('fileChunkSize', fileChunkSize);
            formData.append('fileHash', fileHashMd5);
            xhr.open('POST', '/file2/merge', true);
            xhr.onload = () => {
                if (xhr.status === 200) {
                    resolve(xhr.response);
                } else {
                    reject(xhr.statusText);
                    // 替换所有的 [ 和 ] 字符。移除方括号并根据逗号分割字符串
                    resume(xhr.response.replace(/\[|]/g, '').split(','));
                }
            };
            xhr.onerror = () => {
                reject(xhr.statusText);
            };
            xhr.send(formData);
        });
    }

    async function resume(list) {
        for (let i = 0; i < list.length; i++) {
            try {
                await uploadChunk(file, i);
            } catch (error) {
                console.error('Failed to upload chunk', i, error);
                // 如果上传失败，则尝试恢复上传
                try {
                    await uploadChunk(file, i);
                } catch (error) {
                    console.error('Failed to resume upload', i, error);
                    return;
                }
            }
        }
        // 合并文件
        try {
            const fileUrl = await mergeFile();
            console.log('File URL:', fileUrl);
        } catch (error) {
            console.error('Failed to merge file', error);
        }
    }
</script>
</body>
</html>