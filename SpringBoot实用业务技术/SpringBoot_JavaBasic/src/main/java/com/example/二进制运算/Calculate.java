package com.example.二进制运算;

import cn.hutool.log.Log;

/**
 * @author 游家纨绔
 * @dateTime 2023-10-11 11:29
 * @apiNote TODO 计算机二进制运算
 */
public class Calculate {
    private static final Log log = Log.get(Calculate.class);

    public static void main(String[] args) {

        // 我们十进制是逢十进一，而二进制是（逢二进一）
        //         0  0  1  1                   0  0  1  1
        //     +   0  0  0  1               -   0  0  0  1
        //       --------------               --------------
        //         0  1  0  0                   0  0  1  0
        // 在计算机中，数字通常使用二进制表示。但是，由于二进制数只能表示非负数，所以无法直接使用二进制表示负数。
        // 为了解决这个问题，计算机使用了一种叫做补码的方法来表示负数。
        //
        //     补码是一种将负数转换为二进制的方法，它可以确保所有数的补码都可以使用二进制进行加法运算。
        //     比如运算：a-b == a+(-b); 即结果为 a值加上-b的补码
        //     原码：1111 1001
        //     反码：1000 0110（反码是将原码中的 1变为0，0变为1。但是符号位不变）
        //     补码：1000 0111（补码就是将反码进行加1操作）

        // 1、&（按位与）：如果两位都是1，那么结果是1，否则结果是0。
        int a1 = 60;     // 0011 1100 = 0+0+2²+2³ +2⁴+2⁵+0 = 0+0+4+8 +16+32+0 = 60
        int b1 = 13;     // 0000 1101 = 2⁰+0+2²+2³ +0+0+0 = 1+0+4+8 +0+0+0 = 13
        log.debug("&（按位与）计算结果：{}", (a1 & b1)); // 0000 1100 = 0+0+4+8 +0+0+0 = 12

        // 2、|（按位或）：如果两位至少有一位是1，那么结果是1。
        int a2 = 60;     // 0011 1100 = 0+0+2²+2³ +2⁴+2⁵+0 = 0+0+4+8 +16+32+0 = 60
        int b2 = 13;     // 0000 1101 = 2⁰+0+2²+2³ +0+0+0 = 1+0+4+8 +0+0+0 = 13
        log.debug("|（按位或）计算结果：{}", (a2 | b2)); // 0011 1101 = 1+0+4+8 +16+32+0 = 61

        // 3、^（按位异或）：如果两位是不同的，那么结果是1。
        int a3 = 60;     // 0011 1100 = 0+0+2²+2³ +2⁴+2⁵+0 = 0+0+4+8 +16+32+0 = 60
        int b3 = 13;     // 0000 1101 = 2⁰+0+2²+2³ +0+0+0 = 1+0+4+8 +0+0+0 = 13
        log.debug("^（按位异或）计算结果：{}", (a3 ^ b3)); // 0011 0001 = 1+0+0+0 +16+32+0 = 49

        // 4、~（按位取反）：对二进制中的每一位进行取反操作，如果原来是0，就变为1，如果原来是1，就变为0。
        log.debug("~（按位取反）计算结果：{}", ~6);
        // 值6的二进制表示是 0000 0110，
        // ~6表示对6进行取反，结果为负数，由此得到的二进制是补码 1111 1001。
        //    补码：1111 1001
        //    反码：1111 1000
        //    原码：1000 0111(除开符号位，其他取反)
        // ～6的原码对应的十进制值 1+2+4=7，加上负号符号，结果为-7

        // 5、<<和>>（左移和右移）：左移是将数字的二进制表示向左移动指定的位数，右移是将数字的二进制表示向右移动指定的位数。
        //    移位后的空位将被填充为0。左移和右移的操作结果可能依赖于所操作数的符号，对于无符号数，它们都是非负的。
        int a4 = 6;                                  // 6 = 0000 0110
        log.debug("<<（左移）计算结果：{}", (a4 << 2)); // 结果是 24，6的比特位整体左移2位得到 0001 1000，对应十进制24。
        log.debug(">>（右移）计算结果：{}", (a4 >> 2)); // 结果是 1， 6的比特位整体右移2位得到 0000 0001，对应十进制1。
        // 注意：Java中的右移运算符>>对负数进行操作时会保留符号位，即使移动的位数大于该数能表示的最大位数。
        // 例如：对于一个8位的byte类型数值，如果对其进行超过8位的右移，那么结果将是负数。

        // 6、Java二进制中使用补码来表示负数进行运算
        //   -1     --> 原码：1000 0000 0000 0000 0000 0000 0000 0001
        //              反码：1111 1111 1111 1111 1111 1111 1111 1110
        //              补码：1111 1111 1111 1111 1111 1111 1111 1111
        //   -1<<12 将负数左移12位，用负数做运算应该使用补码
        //          -1的补码：1111 1111 1111 1111 1111 1111 1111 1111
        //        -1<<12补码：1111 1111 1111 1111 1111 0000 0000 0000
        //              反码：1111 1111 1111 1111 1110 1111 1111 1111
        //              原码：1000 0000 0000 0000 0001 0000 0000 0000 --> -(2^12)=-4096
        //   ~(-1<<12) 将负数取反，也就是将负数的补码取反成为正数，正数没有反码的概念，因此取反后就是为结果的原码
        //        -1<<12补码：1111 1111 1111 1111 1111 0000 0000 0000
        //              原码：0000 0000 0000 0000 0000 1111 1111 1111 --> (2^12)+(2^11)+...+1=4095
        int a5 = -1;
        log.debug("负数左移计算结果：{}", a5 << 12);
        log.debug("负数左移后取反计算结果：{}", ~(a5 << 12));
    }
}
