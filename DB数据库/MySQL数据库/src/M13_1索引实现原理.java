/**
 * @author 游家纨绔
 */
/*
索引
1、什么是索引？有什么用?
   [1]、索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。简单来说索引是一种用于快速查找数据的数据结构，
        是帮助MySQL高效获取数据的排好序的数据结构。在数据库方面，查询一张表的时候有两种检索方式：
        第一种方式：全表扫描
        第二种方式：根据索引检索

   [2]、索引为什么可以提高检索效率？
        其实最根本的原理是缩小了扫描的范围。下列举例说明：查询年龄 age=36 的数据 -- SELECT * FROM t_user WHERE age=36
                                 +----+--------------+
                                 | id | name  | age  |
                                 +----+-------+------+
                                 |  1 | 董晓明 | 3    |
                                 |  2 | 孙璐   | 5    |       不加索引的情况下，需要从表的第一行一行遍历，比对 age 的值是否等于 43，
        右图是不加索引的数据 → → →  |  3 | 许致远 | 8     | ︎→ → → 这样需要比对 6次 才能查到。这只是只有几行记录的表，那如果是百万级千万级的表呢？
                                 |  4 | 周璐   | 26   |       是不是就比较的次数就更多了，那查询结果还不得等到来年小曹破壳日。
                                 |  5 | 杜子韬 | 34   |
                                 |  6 | 程致远 | 36   |
                                 |  7 | 龙震南 | 48   |
                                 +----+-------+------+
                                          ㉖
                                       ↙︎    ↘︎               如果 age 这列字段添加了索引，Mysql内部会维护一个数据结构。
        右图是添加索引的数据  → → →     ⑤        ㊱      → → →  假设是红黑树结构:（右子树的元素大于根节点，左子树的元素小于根节点）
                                  ↙︎   ↘︎    ↙︎   ↘︎           的数据结构建立索引，这样的话,查询SQL只需要 2 次磁盘IO就查到了。
                                 ③     ⑧  ㉞      ㊽         (先加载根节点进行比较，大于根节点的值，则遍历右子树进行比较)

        当 age 字段上不加索引的时候，上述查询SQL语句会进行全表扫描，扫描 age 字段中所有的值
        当 age 字段上添加索引的时候，上述查询SQL语句会根据索引扫描，快速定位。
        索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中的对象，也需要不断的维护，是有维护成本的。
        比如：表中的数据经常被修改，这样就不适合添加索引，因为数据一旦被修改，索引需要重新排序，进行维护。

   [3]、什么情况下考虑给字段添加索引？（满足什么条件）
        数据量庞大
        该字段涉及很少的DML操作
        该字段经常出现在 WHERE 条件语句中

   [4]、注意：主键和具有unique约束的字段自动会添加索引。根据主键查询，效率较高。尽量根据主键检索。
---------------------------------------------------------------------------------------------------------------
2、简单认识一下数据结构中的"树"
   [1]、"树"结构是一种非线性存储结构，存储的是具有"一对多"关系的数据元素的集合。
        术语：
            ①、父节点：若一个 节点A 含有 子节点B，则这个节点A为 子节点B 的父节点。
            ②、子节点：一个 节点A 含有子树下的 节点B，那么节点B为 节点A 的子节点。
            ③、兄弟节点：拥有共同父节点的节点互称为兄弟节点。
            ④、度：节点的子树数目就是节点的度(如果节点的子树数目为零，即该节点层级为当前分支的最后一层)。
            ⑤、叶子节点：度为零的节点就是叶子节点(就是没有子树的节点：任意分支下最后一层的所有节点)。
            ⑥、非叶子节点：就是除开叶子节点的其他节点。

                        ㉖                       （㉖）为根节点
                    ↙︎      ↘︎                   （⑤）和（㊱）互为兄弟节点
                  ⑤          ㊱       → → → → → （⑤、㊱）为（㉖）的子节点，为（③、⑧、㉞、㊽）的父节点
               ↙︎    ↘︎     ↙︎   ↘︎               （③、⑧、㉞、㊽）就是叶子节点
             ③       ⑧   ㉞      ㊽             （⑤、㊱、③、⑧、㉞、㊽）为㉖的子树

   [2]、"树"结构具有以下的特点：（不需要记忆，理解就成）
            ①、每个结点有零个或多个子结点;
            ②、没有父结点的结点称为根结点;
            ③、每一个非根结点有且只有一个父结点;
            ④、除了根结点外，每个子结点可以分为多个不相交的子树;
---------------------------------------------------------------------------------------------------------------
3、二叉树
   [1]、比如：依次插入 1、9、5、24、8、30、3... 数据到二叉树，那么在每插入一行数据后就需要维护二叉树这样一个数据结构。
        网址为 https://www.cs.usfca.edu/~galles/visualization/BST.html 可以演示数据结构维护的过程。
        ①          ①            ①                ①                ①                       ①
          ↘︎          ↘︎            ↘︎                ↘︎                ↘︎                       ↘︎
            ⑨          ⑨            ⑨                ⑨                ⑨                       ⑨
                      ↙︎            ↙︎  ↘︎            ↙︎  ↘︎             ↙︎  ↘︎                   ↙︎   ↘︎
                    ⑤            ⑤      ㉔        ⑤      ㉔         ⑤      ㉔               ⑤       ㉔
                                                     ↘︎                ↘︎       ↘︎   ︎        ↙︎   ↘︎       ↘︎
                                                       ⑧                ⑧       ㉚       ③      ⑧       ㉚
   [2]、假如依次插入 1、2、3、4、5、6、7... 通过网址演示插入这些数据，我们可以看到这样的一个二叉树是不是一直在单边增长，没有左子树。
        ①
          ↘︎
            ②     缺点：这种二叉树和我们学过的链表是不是很像，也就是说二叉树在某些场景下退化成了链表。
              ↘︎        链表的查找是需要从头部遍历的，这时候和没加索引从表的第一行遍历几乎没太大区别！这也是二叉树作为索引底层数据结构的弊端之一。
                ③      同样也是Mysql索引底层没有使用二叉树这种数据结构的原因之一。
                  ↘︎
                    ④ ...
---------------------------------------------------------------------------------------------------------------
4、红黑树（自平衡二叉树）
   [1]、为了避免普通的二叉查找树在极端情况下可退化成链表，就出现了一些自平衡的查找树，比如 AVL，红黑树等。这些自平衡的查找树通过定义一些性质，
        将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态。红黑树是一种自平衡的二叉查找树，是一种高效的查找树。
        依次插入 1、2、3、4、5、6、7、8、9... 数据到红黑树。
        ①           ②          ②          ②          ②           ②                ④                 ④
          ↘︎        ↙︎ ↘︎       ↙︎ ↘︎       ↙︎  ↘︎       ↙︎ ↘︎        ↙︎ ↘︎             ↙︎  ↘︎             ↙︎  ↘︎
            ②     ①   ③     ①   ③     ①    ④     ①   ④      ①   ④           ②     ⑥          ②     ⑥
                                    ↘︎        ↙︎ ↘︎       ↙︎ ↘︎︎        ↙︎ ↘︎  ︎      ↙︎ ↘︎   ↙︎ ↘︎       ↙︎ ↘︎   ↙︎ ↘︎
                                     ④      ③   ⑤     ③   ⑤      ③    ⑥     ①  ③  ⑤   ⑦     ①  ③  ⑤   ⑧
                                                              ↘︎         ↙︎ ↘︎                 ↘︎              ↙︎ ↘︎
                                                               ⑥       ⑤   ⑦                 ⑧            ⑦   ⑨
---------------------------------------------------------------------------------------------------------------
5、B树（B-Tree）
     B-Tree作为索引的数据结构，可以在一个节点上存储更多的元素，元素为 k-v键值对 的形式。
     key 就是索引字段，data 就是索引字段所在的那一行的数据或是那一行数据所在的磁盘文件地址（或叫指针）。
         +---------+----------+---------+----------+---------+----------+----------+
         |         |    15    |         |    56    |         |    77    |          |
         +---------+----------+---------+----------+---------+----------+----------+
             ⬇︎     |   data   |    ⬇︎    |   data   |    ⬇︎   |   data   |    ⬇︎
             ⬇︎     +----------+    ⬇︎    +----------+    ⬇︎   +----------+      ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎
             ⬇︎                     ⬇︎                    ⬇︎                                               ⬇︎
             ⬇︎                      ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎         ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎
             ⬇︎                                   ⬇︎                                     ⬇︎                ⬇︎
      +---------+       +---------+----------+--------+----------+---------+       +--------+       +--------+
      | ......  |       |         |    20    |        |    49    |         |       | ...... |       | ...... |
      +---------+       +---------+----------+--------+----------+---------+       +--------+       +--------+
                                  |   data   |        |   data   |
                                  +----------+        +----------+
   [1]、正常根据树结构查询，每次查询都只会加载一个节点(该节点可看成一个元素)到内存里，进行比对索引值，然后判断是否需要查询子节点来满足其条件。
        使用 B-Tree 这种数据结构查找元素就不是每次 Load 单个元素，而是把一个大的节点数据(范围内元素)全部 Load 到内存，在内存里比对。
        比如：我们要查找索引值为 49 的元素，实际上是从根节点开始查找，它一次性将 根节点(索引值为15、56、77的范围元素) Load到内存里，
             然后用要查找的元素 49 去比对。15 < 49 < 56，在 15 和 56 之间有一个节点，存储的是下一个节点的磁盘地址，指向下一个节点，
             这个节点(索引值为20、49的范围元素)的索引都是大于15小于56的，然后再将这个节点 Load 到内存去比对元素，最终找到索引值为 49 的元素。
        注意：Load一次节点是将 节点的数据从物理存储介质（如硬盘）读取到内存当中，也就是一次磁盘IO，这个读取过程相对来说是比较慢的。
             该节点全部 Load 到内存中之后，再在内存里实现元素更高效的数据处理和访问。

   [2]、按照上述 Load 规则：树的高度越小需要 load 的次数就越少，那么查询时间就越短。
        按这种思路把一个表的数据都放到一个大的节点上，然后把这个节点一次性 Load 到内存里，在内存里一个个去比对，是否可行呢？
        答案是否定的。
        假如我们有几千万数据，在磁盘上面全部放到一个节点上去是不可能的，你的数据表是一行行插入的，存在磁盘上面几百兆甚至几个G，
        一次性 Load 到内存中合适吗？内存本来就有限，而且如果你学过《计算机组成原理》那么也知道，磁盘IO跟内存打交道的单位是 4K，
        一次可能读取 4K 的数据，也有可能一些局部读取的原理导致会取 几十K（4的整数倍），取个16K、24K也是可以的 。
        但是一次交互取几百兆甚至几个G是搞不定的，这是计算机组成原理定的 [乌龟的屁股--龟腚(规定)] ，一次磁盘IO取那么多数据，
        对内存来说也是非常的浪费，而且大数据量的磁盘IO是非常慢的，所以这个节点的大小设置要合适。
        Mysql对节点大小设置的是16K，用下面这个SQL就是可以查到：show global status like 'Innodb_page_size'
---------------------------------------------------------------------------------------------------------------
6、B+树（B+Tree）
     MySQL选择的索引数据结构 不是原生的 B-Tree 结构，而是选择了 B-Tree 进行了改造后得到的 B+Tree 的数据结构。
                             +---------+----------+---------+----------+---------+----------+----------+
                             |         |    15    |         |    56    |         |    77    |          |
                             +---------+----------+---------+----------+---------+----------+----------+
                                                       ⬇︎                   ⬇︎                    ⬇︎
                                    ⬅︎ ⬅︎ ⬅︎ ⬅︎ ⬅︎ ⬅︎ ⬅︎ ⬅︎︎                     ➡︎ ➡︎ ➡︎ ➡︎             ➡︎ ➡︎ ➡︎
                                   ⬇︎                                                  ⬇︎                 ⬇︎
                                   ⬇︎                                                  ⬇︎                 ⬇︎
         +----------+---------+----------+---------+----------+------------+       +--------+        +--------+
         |    15    |         |    20    |         |    49    |            |       | ...... |        | ...... |
         +----------+---------+----------+---------+----------+-------︎-----+       +--------+        +--------+
                         ⬇︎                   ⬇︎                            ⬇︎
                         ⬇︎                   ⬇︎                            ⬇︎
                ⬅︎ ⬅︎ ⬅︎ ⬅︎                  ︎
               ⬇︎                             ⬇︎                            ⬇︎
     +-------------------+           +-----------------+         +------------------+
     |   15    |    18   |   → → →   |   20   |   30   |  → → →  |    49   |   50   |   ➔ ➔
     +---------+---------+           +--------+--------+         +---------+--------+
     |   data  |   data  |           |  data  |  data  |         |   data  |   data |
     +---------+---------+           +--------+--------+         +---------+--------+
   [1]、B+Tree 与 B-Tree 有什么区别？
        1、B树的节点中没有重复元素，B+树有。
        2、B+Tree 的非叶子节点没有存表的行数据，数据都挪到叶子节点。
        3、叶子节点之间有指针，非叶子节点之间没有指针跟 B-Tree 一样。

   [2]、为什么把data元素挪到叶子节点？
        这样非叶子节点只存储索引元素，对于同一片大小的存储空间来说就可以存储更多的索引元素，而叶子节点存储一份完整表的所有行的索引字段。
        实际上非叶子节点存储的是一些冗余索引，看一下上图，15、20、49在整个树中出现多次。对于冗余索引选择的是整张表的哪些数据作为索引呢？
        选择的是处于中间位置的，因为它要用到 B+Tree 比大小去查找，B+Tree 本质可以叫做多叉平衡树，单看 B+Tree 的某一小块他还是一个二叉树。
        比如：查找索引值为 30 的数据，先在根节点跟 15 去比较，大于15，然后小于56，然后从他俩中间的指针查找下一个节点把它 Load 到内存，
        再在内存里去比对，大于15，大于20，然后小于49，就根据20和49之间的指针找到下一个节点，然后Load到内存去比对，继而找到 30 的数据。
---------------------------------------------------------------------------------------------------------------
7、Mysql索引的特点
   Mysql的索引原理和数据结构是基于B树（B-tree）的数据结构。B树是一种自平衡的搜索树，它能够高效地支持数据的插入、删除和查找操作。
   具体而言，Mysql中的索引使用的是B+树数据结构，它是B树的一种变体。
   B+树相比于B树有以下特点：
       [1]、B+树的非叶子节点不存储实际的数据，只存储索引信息，这使得B+树的节点可以存储更多的索引信息并且高度更低，减少了磁盘I/O的次数。
       [2]、B+树的叶子节点使用链表连接，可以支持范围查询和排序操作。
       [3]、B+树的叶子节点按照键值大小顺序存储，提升了范围查询的效率。
       [4]、Mysql的索引是存储在磁盘上的，具体存储在数据库目录下的数据库文件中。
            索引文件使用MYI扩展名，其中存储了B+树数据结构的索引信息和表中数据的关联关系。
            通过使用索引，Mysql可以快速定位到符合特定条件的数据，提高了查询效率。
 */
public class M13_1索引实现原理 {
}
