/**
 * @author 游家纨绔
 * @dateTime 2023-10-03 02:44
 * @apiNote MVCC详解
 */
/* 1、什么是 MVCC？
 *          MVCC，即Multi-Version Concurrency Control(多版本并发控制)
 *       它是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。
 *
 *          通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，在某个事务对其进行操作的时候，
 *       需要查看这一条记录的隐藏列事务版本id，比对事务id并根据事物隔离级别去判断读取哪个版本的数据。数据库隔离级别读已提交、可重复读 都是基于MVCC实现的，
 *       相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。
 *
 *          MVCC只在 读已提交、可重复读 两个隔离级别下工作，其他两个隔离级别和MVCC不兼容。
 *       读未提交 总是读取最新的数据行, 而不是符合当前事务版本的数据行。序列化读 则会对所有读取的行都加锁。
 * ---------------------------------------------------------------------------------------------------------------
 * 2、MVCC实现的关键知识点
 *    [1]、事务版本号
 *         事务每次开启前，都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。
 *
 *    [2]、隐式字段
 *         对于InnoDB存储引擎，每一行记录都有两个隐藏列 trx_id、roll_pointer，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列 row_id(不常用)
 *         trx_id       必须隐藏列  ①、表示当前数据事务的id，MySQL会为每个事务分配一个id，这个id是递增的
 *                                ②、当对表执行insert，delete，update语句时，才会为事务分配唯一的事务id，否则一个事务的事务id值为默认值，
 *                                    这个默认值不固定，innodb使用当前事务的trx变量的地址转换成整数，然后在加上2的48次方计算得来的。
 *         roll_pointer 必须隐藏列     相当于一个回滚指针，指向这个事务之前的undo log，就是上一个事务Id指向的数据
 *         row_id       不是必须隐藏列  单调递增的行ID，不是必需的，占用6个字节。
 *
 *    [3]、Undo Log日志
 *         ①、Undo：意为撤销或取消，undo即返回指定某个状态的操作。undo log顾名思义：回滚日志，用于记录数据被修改前的信息。
 *             undo log中主要保存了数据的基本信息，比如说：日志开始的位置、结束的位置，主键的长度、表id，日志编号、日志类型
 *            此外，undo log在记录日志时候也包含两个隐藏字段 trx_id 和 roll_pointer。
 *
 *         ②、Undo Log分类
 *            （1）insert undo log 是在 insert操作 中产生的 undo log。因为 insert操作 的记录只对事务本身可见，对于其它事务，
 *                此记录是不可见的，所以 insert undo log 可以在事务提交后直接删除而不需要进行purge操作。
 *            （2）update undo log 是 update或delete操作 中产生的 undo log。因为会对已经存在的记录产生影响，为了提供 MVCC机制，
 *                因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入history list上，等待purge线程进行最后的删除操作。
 *
 *         ③、在表记录修改之前，会先把数据拷贝到 undo log 里，如果事务回滚，即可以通过 undo log 来还原数据。
 *            当delete一条记录时(delete from core_user where id=1;)，undo log中会记录一条对应的insert记录(insert into core_user select * from core_user where id=1;)；
 *            当update一条记录时(update user set name="李四" where id=1; 修改之前name=张三)，undo log中会记录一条对应的update之前数据的记录(update user set name="张三" where id=1;)。
 *
 *         ④、Undo Log有什么用途呢？
 *            （1）如果某些原因导致事务失败或回滚，可以借助该undo log进行回滚。事务回滚时，可以保证原子性和一致性。
 *            （2）用于MVCC快照读。
 *
 *    [4]、Undo Log版本链
 *         Undo Log版本链是基于 Undo Log 实现的。
 *         多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针(roll_pointer),连成一个链表,这个链表就称为版本链。
 *
 *         ①、假设现在有一张core_user表，表里面插入一条数据，id为1，name为孙权：
 *                                   +--------+--------+--------------+-----+------+
 *                                   | ROW_ID | TRX_ID | ROLL_POINTER | id  | name |
 *            -- core_user表中数据    +--------+--------+--------------+-----+------+
 *                                   | NULL   | 100    | NULL         | 1   | 孙权  |
 *                                   +--------+--------+--------------+-----+------+
 *         ②、现在开启一个事务A：对core_user表执行 UPDATE core_user SET name ="曹操" WHERE id=1; 会进行如下流程操作
 *                                   +--------+--------+--------------+-----+------+
 *                                   | ROW_ID | TRX_ID | ROLL_POINTER | id  | name |
 *            -- core_user表中数据    +--------+--------+--------------+-----+------+
 *                                   | NULL   | 101    | 0x0123       | 1   | 曹操  |
 *                                   +--------+--------+------⬇︎------+-----+-------+
 *                                                            ⬇︎
 *                                                             ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎ ➡︎                                  ⬇︎
 *                                   +--------+--------+--------------+-----+------+             ⬇︎
 *                                   | ROW_ID | TRX_ID | ROLL_POINTER | id  | name |             ⬇︎
 *            -- undo log日志拷贝数据  +--------+--------+--------------+-----+------+             ⬇︎
 *                                   | NULL   | 100    | NULL         | 1   | 孙权  | ⬅︎ ⬅︎ ⬅︎ ⬅︎ ⬅︎
 *                                   +--------+--------+--------------+-----+------+
 *             （1）把 core_user 表修改前的数据(即事务ID=100)，拷贝到 undo log（update core_user set name='孙权' where id=1;）
 *             （2）修改 core_user 表中 id=1 的数据，name改为曹操
 *             （3）把修改操作 事务Id=101 的数据里 隐藏列 roll_pointer 指向 undo log 中事务 Id=100 的数据地址。
 *
 *    [5]、快照读和当前读
 *         ①、快照读：读取的是记录数据的可见版本(读取 undo log 中的数据)。不加锁,普通的select语句都是快照读,如：
 *                   SELECT * FROM core_user WHERE id > 2;
 *         ②、当前读：读取的是记录数据的最新版本，显式加锁的都是当前读（读取实际表中数据）
 *              (1)、添加共享锁：Mysql数据库允许同一资源在事务下添加共享锁后，其他事务可以添加共享读锁，但不能再添加排他写锁。
 *                             且当前添加共享锁的事务只能读不能修改。允许其他人读取资源，但是禁止其他人删除，修改资源。
 *                   SELECT * FROM core_user WHERE id > 2 lock in share mode;
 *              (2)、添加排他锁：Mysql数据库不允许同一资源在事务下添加排他锁后，其他事务再添加共享读锁或排他写锁。
 *                             允许其他人普通无锁读取资源，但是禁止其他人删除，修改资源。
 *                   SELECT * FROM core_user WHERE id > 2 for update;
 *
 *    [6]、Read View
 *         Read View 就是事务执行SQL语句时，产生的读视图。实际上在innodb中，每个SQL语句执行前都会得到一个Read View。
 *         主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据~
 *
 *         Read View的重要属性
 *            m_ids:          当前系统中那些活跃(未提交)的读写事务ID, 它数据结构为一个List。一旦事务提交，对应事务ID就会被剔除
 *            min_limit_id:   表示在生成ReadView时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值。
 *            max_limit_id:   表示生成ReadView时，系统中应该分配给下一个事务的id值，即m_ids中的id最大值 + 1
 *            creator_trx_id: 生成该ReadView的事务的事务id（通常就是当前的事务ID）
 *
 *         如果[隐式字段事务ID] trx_id < min_limit_id，表明生成该版本的事务在生成ReadView前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。
 *         如果 trx_id >= max_limit_id，表明生成该版本的事务在生成 Read View 后才生成，所以该版本不可以被当前事务访问。
 *         如果 min_limit_id =< trx_id < max_limit_id，需要分3种情况讨论
 *            ①、如果 m_ids 包含 trx_id，则代表Read View生成时刻，这个事务还未提交，但是如果数据的trx_id等于creator_trx_id的话，表明数据是自己生成的，因此是可见的。
 *            ②、如果 m_ids 包含 trx_id，并且trx_id不等于creator_trx_id，则ReadView生成时，事务未提交，并且不是自己生产的，所以当前事务也是看不见的；
 *            ③、如果 m_ids 不包含 trx_id，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。
 *
 *         已提交读 隔离级别下的事务在每次查询的开始都会生成一个独立的 ReadView，也就是每次查询都会生成新的 ReadView。
 *         可重复读 隔离级别则在第一次读的时候生成一个 ReadView，之后的读都复用之前的 ReadView，使用的是同一个 ReadView。
 * ---------------------------------------------------------------------------------------------------------------
 * 3、MVCC实现原理（解决不可重复读问题分析）
 *                  事务A(TRX_ID=100)                                事务B(TRX_ID=101)
 *                      begin                                             begin
 *         insert into core_user value(1, "孙权");
 *         select * from core_user where id=1;
 *                                                        update core_user set name='曹操' where id=1;
 *                                                                        commit
 *         select * from core_user where id=1;
 *                      commit
 *
 *    [1]、读已提交（RC隔离级别）存在不可重复读问题分析历程：
 *          ①、A开启事务，在执行 INSERT语句 分配到唯一事务ID为100; B开启事务，在执行 UPDATE语句 分配到唯一事务ID为101
 *          ②、表数据 id=1的数据行中隐藏列 TRX_ID=100
 *                                     +--------+--------+--------------+-----+------+
 *                                     | ROW_ID | TRX_ID | ROLL_POINTER | id  | name |
 *              -- core_user表中数据    +--------+--------+--------------+-----+------+
 *                                     | NULL   | 100    | NULL         | 1   | 孙权  |
 *                                     +--------+--------+--------------+-----+------+
 *          ③、事务A第一次执行 SELECT语句 之前生成一个Read View
 *                                     +----------------+---------+
 *                                     | m_ids          | 100,101 |
 *                                     +----------------+---------+
 *                                     | max_limit_id   | 102     |
 *              -- Read View对应的值    +----------------+---------+
 *                                     | min_limit_id   | 100     |
 *                                     +----------------+---------+
 *                                     | creator_trx_id | 100     |
 *                                     +----------------+---------+
 *              然后回到undo log版本链，开始从undo log版本链中挑选可见的记录
 *                 min_limit_id(100) =< trx_id(100)[表数据行的隐藏列TRX_ID] < max_limit_id(102);
 *                 creator_trx_id = trx_id = 100;
 *              由此可得，trx_id=100的这个记录，当前事务是可见的。所以查到是name为孙权的记录
 *          ④、事务B进行修改操作，把name改为曹操。把原数据拷贝到undo log,然后对数据进行修改，标记事务ID和上一个数据版本在undo log的地址。
 *                                     +--------+--------+--------------+-----+------+
 *                                     | ROW_ID | TRX_ID | ROLL_POINTER | id  | name |
 *              -- core_user表中数据    +--------+--------+--------------+-----+------+
 *                                     | NULL   | 101    | 0x0123       | 1   | 曹操  |
 *                                     +--------+--------+--------------+-----+------+
 *          ⑤、提交事务B
 *          ⑥、事务A第二次执行查询操作之前，新生成一个Read View
 *                                     +----------------+---------+
 *                                     | m_ids          | 100     |
 *                                     +----------------+---------+
 *                                     | max_limit_id   | 102     |
 *              -- Read View对应的值    +----------------+---------+
 *                                     | min_limit_id   | 100     |
 *                                     +----------------+---------+
 *                                     | creator_trx_id | 100     |
 *                                     +----------------+---------+
 *              然后再次回到undo log版本链，从undo log版本链中挑选可见的记录
 *                 min_limit_id(100) =< trx_id(101)[表数据行的隐藏列TRX_ID] < max_limit_id(102);
 *                 trx_id=101 不属于 m_ids{100}集合。
 *              因此，trx_id=101 这个记录，对于当前事务是可见的，事务A第二次执行查询操作的是name为曹操的记录。
 *
 *         综上所述：在读已提交（RC）隔离级别下，同一个事务里，两个相同的查询，读取同一条记录（id=1），
 *                 却返回了不同的数据（第一次查出来是孙权，第二次查出来是曹操那条记录）。因此RC隔离级别，存在 不可重复读并发问题。
 *
 *    [2]、可重复读（RR隔离级别）解决不可重复读问题分析：
 *          ①、A开启事务，在执行 INSERT语句 分配到唯一事务ID为100; B开启事务，在执行 UPDATE语句 分配到唯一事务ID为101
 *          ②、表数据 id=1的数据行中隐藏列 TRX_ID=100
 *                                     +--------+--------+--------------+-----+------+
 *                                     | ROW_ID | TRX_ID | ROLL_POINTER | id  | name |
 *              -- core_user表中数据    +--------+--------+--------------+-----+------+
 *                                     | NULL   | 100    | NULL         | 1   | 孙权  |
 *                                     +--------+--------+--------------+-----+------+
 *          ③、事务A第一次执行 SELECT语句 之前生成一个Read View
 *                                     +----------------+---------+
 *                                     | m_ids          | 100,101 |
 *                                     +----------------+---------+
 *                                     | max_limit_id   | 102     |
 *              -- Read View对应的值    +----------------+---------+
 *                                     | min_limit_id   | 100     |
 *                                     +----------------+---------+
 *                                     | creator_trx_id | 100     |
 *                                     +----------------+---------+
 *              然后回到undo log版本链，开始从undo log版本链中挑选可见的记录
 *                 min_limit_id(100) =< trx_id(100)[表数据行的隐藏列TRX_ID] < max_limit_id(102);
 *                 creator_trx_id = trx_id = 100;
 *              由此可得，trx_id=100的这个记录，当前事务是可见的。所以查到是name为孙权的记录
 *          ④、事务B进行修改操作，把name改为曹操。把原数据拷贝到undo log,然后对数据进行修改，标记事务ID和上一个数据版本在undo log的地址。
 *                                     +--------+--------+--------------+-----+------+
 *                                     | ROW_ID | TRX_ID | ROLL_POINTER | id  | name |
 *              -- core_user表中数据    +--------+--------+--------------+-----+------+
 *                                     | NULL   | 101    | 0x0123       | 1   | 曹操  |
 *                                     +--------+--------+--------------+-----+------+
 *          ⑤、提交事务B
 *          ⑥、事务A第二次执行查询操作，生成一个Read View副本（就是第一次的Read View）
 *                                     +----------------+---------+
 *                                     | m_ids          | 100,101 |
 *                                     +----------------+---------+
 *                                     | max_limit_id   | 102     |
 *              -- Read View对应的值    +----------------+---------+
 *                                     | min_limit_id   | 100     |
 *                                     +----------------+---------+
 *                                     | creator_trx_id | 100     |
 *                                     +----------------+---------+
 *              然后再次回到undo log版本链，从undo log版本链中挑选可见的记录
 *                 min_limit_id(100) =< trx_id(101)[表数据行的隐藏列TRX_ID] < max_limit_id(102);
 *                 m_ids{100,101}集合 包含 trx_id(101)
 *                 creator_trx_id(100) != trx_id(101)
 *              所以，trx_id=101 这个记录对于当前事务是不可见的。这时候undo log版本链roll_pointer跳到下一个版本trx_id=100这个记录，
 *              再次校验 trx_id=100 这个版本是否可见，如果可见便返回查询数据，不可见便继续跳到下一版本：
 *                 min_limit_id(100) =< trx_id(100) < max_limit_id(102);
 *                 m_ids{100,101} 包含 trx_id(100)
 *                 creator_trx_id(100) 等于 trx_id(100)
 *              所以 trx_id=100 这个记录，对于当前事务是可见的。事务A第二次执行查询操作的是name为孙权的记录。
 *
 *        综上所述：在 可重复读（RR）隔离级别下，同一个事务里，两个相同的查询，读取同一条记录（id=1），返回了相同的数据。
 *                复用老的Read View副本，解决了不可重复读的问题。
 * ---------------------------------------------------------------------------------------------------------------
 * 4、MVCC解决幻读问题分析
 *        ##### 可知 core_user 表中一共有 id{1,2,3} 的数据行，对应id值的名为 name 列数据分别为{'孙权','曹操','赵云'}
 *
 *        [1]、RR级别下，快照读(普通 SELECT)的例子，不存在幻读问题
 *                             事务A(TRX_ID=100)                                     事务B(TRX_ID=101)
 *                                  begin                                                 begin
 *                  select count(*) from core_user where id>1;
 *                                                                         insert into core_user value(4, "刘备");
 *                                                                                        commit
 *                  select count(*) from core_user where id>1;
 *                                  commit
 *             ①、在 RR隔离级别下，事务A 第一次执行 SELECT 语句时生成了一个 ReadView。
 *                                       +----------------+---------+
 *                                       | m_ids          | 100,101 |
 *                                       +----------------+---------+
 *                                       | max_limit_id   | 102     |
 *                -- Read View对应的值    +----------------+---------+
 *                                       | min_limit_id   | 100     |
 *                                       +----------------+---------+
 *                                       | creator_trx_id | 100     |
 *                                       +----------------+---------+
 *             ②、读取到的 id{2,3}数据行中的隐藏列 TRX_ID=99，校验其可见性：trx_id(99)[表数据行的隐藏列TRX_ID] < min_limit_id(100);
 *                所以 trx_id=99 的这些记录，对于当前事务是可见的。因此第一次 SELECT结果为 2，且读取到的 id{2,3}数据行会被添加上共享锁。
 *             ③、事务B 执行 INSERT语句，新增 id=4 的记录
 *                                       +--------+--------+--------------+-----+------+
 *                                       | ROW_ID | TRX_ID | ROLL_POINTER | id  | name |
 *                -- core_user表中数据    +--------+--------+--------------+-----+------+
 *                                       | NULL   | 101    | NULL         | 4   | 刘备  |
 *                                       +--------+--------+--------------+-----+------+
 *             ④、事务A 第二次执行 SELECT 语句时生成了一个 ReadView副本(RR隔离级别下，同一事务从始至终只有一个ReadView)。
 *                然后读取符合 WHERE 条件的数据：id{2,3}数据行中的隐藏列 TRX_ID=99; id=4数据行中的隐藏列 TRX_ID=101。
 *                校验 TRX_ID=101 可见性：min_limit_id(100) =< trx_id(101)[表数据行的隐藏列TRX_ID] < max_limit_id(102);
 *                                      m_ids{100,101} 包含 trx_id(101)
 *                                      creator_trx_id(100) 不等于 trx_id(101)
 *                因此，新增的 trx_id=101 的这条记录，对于当前事务是不可见的。所以第二次 SELECT结果还是为 2。
 *
 *
 *        [2]、RR级别下，当前读(加锁 SELECT)的例子，不存在幻读问题
 *                             事务A(TRX_ID=100)                                     事务B(TRX_ID=101)
 *                                  begin                                                 begin
 *        select count(*) from core_user where id>1 lock in share mode;
 *                                                                          insert into core_user value(4, "刘备");
 *             ①、分析上述流程，显然 事务B 执行插入操作时阻塞了。因为 事务A 在执行 select ... lock in share mode(当前读)时添加了共享锁，
 *                只能读取不能修改。不仅在 id{2,3} 这2条数据上加了记录锁，而且在 id > 1 这个范围上也加了间隙锁。
 *             ②、因此我们可以发现，RR隔离级别下，加锁的select、update、delete等语句，会使用 记录锁 + 间隙锁，锁住索引记录之间的范围，
 *                避免范围间插入记录，以避免产生幻影行记录。
 *
 *
 *        [3]、RR级别下，特殊场景，MVCC似乎存在幻读问题
 *                             事务A(TRX_ID=100)                                     事务B(TRX_ID=101)
 *                                  begin                                                 begin
 *                  select count(*) from core_user where id>1;
 *                                                                         insert into core_user value(4, "刘备");
 *                                                                                        commit
 *                  update core_user set name='张飞' where id=4;
 *                  select count(*) from core_user where id>1;
 *                                  commit
 *             ①、其实在这种场景中，上述流程只是在 事务A 中多加了 update core_user set name='张飞' where id=4; 这步操作。
 *             ②、在 RR隔离级别下，事务A 第一次执行 SELECT 语句时生成了一个 ReadView 读视图。
 *                Read View对应的值： m_ids{100,101}、 max_limit_id=102、 min_limit_id=100、 creator_trx_id=100
 *                读取到的 id{2,3}数据行中的隐藏列 TRX_ID=99，校验其可见性：trx_id(99)[表数据行的隐藏列TRX_ID] < min_limit_id(100);
 *                所以 trx_id=99 的这些记录，对于当前事务是可见的。因此第一次 SELECT结果为 2，且读取到的 id{2,3}数据行会被添加上共享锁。
 *             ③、随后 事务B 向 core_user 表中新增一条记录并提交，而且插入的数据 id=4,name='刘备' 的记录隐藏列 TRX_ID=101。
 *                由于 事务B 已经提交，事务A 中的 ReadView 并不能阻止其执行 UPDATE或DELETE 语句来修改新插入的 id=4 记录。
 *                并且 事务A 修改 id=4 的这条数据行在此时是没有任何锁机制的，所以 事务A 在修改数据行时添加排他锁不会有任何阻塞。
 *                这样一来，这条新记录的隐藏列 trx_id值 就变成了事务A 的事务id（trx_id=100）。
 *             ④、最后 事务A 第二次执行 SELECT 语句时生成了一个 ReadView副本(RR隔离级别下，同一事务从始至终只有一个ReadView)。
 *                然后读取符合 WHERE 条件的数据：id{2,3}数据行中的隐藏列 TRX_ID=99; id=4数据行中的隐藏列 TRX_ID=100
 *                校验 TRX_ID=100 可见性：min_limit_id(100) =< trx_id(100)[表数据行的隐藏列TRX_ID] < max_limit_id(102);
 *                                      m_ids{100,101} 包含 trx_id(100)
 *                                      creator_trx_id(100) 等于 trx_id(100)
 *                因此，新增的 id=4 数据行隐藏列 trx_id=100 的这条记录，对于当前事务是可见的。所以第二次 SELECT结果为 3。
 *             ⑤、因为这个特殊现象的存在。同一个事务，相同的sql，查出的结果集不同了，这个结果符合了幻读的定义。可以认为 MVCC并不能完全禁止幻读。
 */
public class L12_2快照读MVCC {}
