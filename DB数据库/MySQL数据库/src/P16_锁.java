/**
 * @author 游家纨绔
 */
/* 1、在Mysql数据库里的Innodb存储引擎下，默认隔离级别为 '可重复读'：
 *      [1]、事务下的普通查询 SELECT语句 会自动为查询的行记录添加共享锁。以确保其他事务不会对该行进行排他操作，从而保证数据的一致性和隔离性。
 *           非事务的普通查询 SELECT语句 是没有任何锁机制的。
 *
 *      [2]、SELECT 语句添加锁：
 *              共享锁：select * from t_user where id>1 lock in share mode;
 *              排他锁：select * from t_user where id>1 for update; 事务必须排队执行，数据锁住了，不允许并发。
 *              注意：lock in share mode 和 for update 生效需要满足两个条件：
 *                   ①、数据库的存储引擎为InnoDB
 *                   ②、操作位于事务块中(begin/commit)
 *
 *      [3]、INSERT、UPDATE、DELETE 语句都会自动添加上排他锁。
 *
 * 2、MySQL从锁的粒度上分类
 *      [1]、行锁：顾名思义，行锁就是上锁会锁一行或者锁多行记录，MySQL的行锁是基于索引加载的，所以行锁是要加在索引响应的行上，即命中索引，
 *                比如数据库表中有一个主键索引和一个普通索引，SQL语句基于索引查询，命中两条记录。此时行锁一锁就锁定两条记录，
 *                当其他事务访问数据库同一张表时，被锁定的记录不能被访问，其他的记录都可以访问到。注意InnoDB存储引擎的默认锁类型。
 *           特征：锁冲突概率低，并发性高，但是会有死锁的情况出现(比如两个事务同时查询两条相同的行记录，但是彼此交叉进行就会出现死锁)
 *
 *      [2]、页级锁：对表中的页进行加锁，每页的大小是固定的，一般为4KB，一次可以锁定多行数据，提高了并发度和性能，适用于较大数据块的操作。
 *           特征：开销和加锁时间界于表锁和行锁之间，会出现死锁，并发度一般。
 *
 *      [3]、表锁：顾名思义，表锁就是上锁会锁一整张表，在表被锁定期间，其他事务不能对该表进行操作，必须等当前表的锁被释放后才能进行操作。
 *                表锁响应的是非索引字段，即全表扫描，全表扫描时锁定整张表。
 *           特征：由于表锁每次都是锁一整张表，所以表锁的锁冲突几率特别高，表锁不会出现死锁的情况。
 *                当更新数据库数据时，如果没有触发索引，则会锁表，锁表后再对表做任何变更操作都会导致锁冲突，所以表锁的锁冲突概率较高。
 *
 *      [4]、记录锁(Record Lock)：属于行锁中的一种，是指对表中某一行记录进行锁定的机制（只会锁定一行记录，锁多行数据用的锁肯定不是记录锁）
 *                              '记录锁' 的粒度较小，在并发操作时，记录锁的获取和释放可能会导致性能问题。
 *           例如：事务A和事务B同时对同一行记录进行更新操作，事务A首先获取了该行记录的记录锁，然后事务B也获取了该行记录的记录锁，
 *                接着两个事务互相等待对方释放记录锁，从而形成了死锁。
 *           特征：当一个事务对表中的某一行记录进行读取或修改时，会为该行数据添加 '记录锁'，其他事务如果要对同一行记录进行操作，必须等待记录锁被释放。
 *                '记录锁' 可以防止数据的一致性问题，确保在一个事务执行过程中，其他事务不能修改同一行记录。避免查询时被修改的不可重复读问题，
 *                也避免了事务在修改后但未提交被其他事务读取的脏读问题。
 *
 *      [5]、间隙锁(Gap Lock)：属于行锁中的一种，'间隙锁'是在事务加锁后锁住满足条件的索引列空隙区间，防止其他事务在这个范围中插入新的行,
 *                            但是可以修改数据。很明显可以锁住多行数据。
 *           例如：select * from t_user where id>1 and id<4 for update;
 *                这个SQL语句添加 '排他锁' 的方式使用 '间隙锁'，锁住间隙区间 (1,4)，避免其他事务对这个区间数据进行新增。
 *           特征：事务并发的时候，如果没有间隙锁，就会发生幻读问题，在同一个事务里，A事务的两次查询出的结果会不一样。
 *                间隙锁只会出现在 REPEATABLE_READ(可重复读) 的事务级别中。
 *
 *      [6]、临键锁(Next-Key Lock)：属于行锁的一种，就是 '记录锁' 和 '间隙锁' 的组合，'临键锁'会把查询出来的记录锁住，
 *                                同时也会把该范围查询内的所有间隙空间也会锁住，防止其他事务在这个范围中插入新的行或者更新已经存在的行。
 *           例如：select * from t_user where id>1 and id<=4 for update;
 *                这个SQL语句添加 '排他锁' 的方式使用 '临键锁'，锁住间隙区间 (1,4]，避免其他事务对这个区间数据进行新增或修改。
 *           特征：结合 '记录锁' 和 '间隙锁' 的特性，'临键锁' 避免了在范围查询时出现脏读、不可重复读、幻读问题。
 *                添加了 '临键锁' 之后，在范围区间内的数据不允许被修改和插入。当前读就使用了 '临键锁'。
 *
 * 3、MySQL从锁的属性上分类
 *      [1]、共享锁(shared lock)：又叫做读锁，简称S锁。指的是一个事务在一行数据加上 '共享锁' 后，其他事务只能在其上加 '共享锁'，互相不会阻塞，
 *                               但不能添加 '排他锁'。就是多个事务只能读数据不能改数据，包括当前添加 '共享锁' 的事务只能读不能修改。
 *                               在共享锁中，通常只有行锁，没有表锁。因为表锁会阻塞其它事务对同一张表的所有操作，影响并发性能。
 *
 *      [2]、排他锁(exclusive lock)：又叫做写锁，简称X锁。指的是一个事务在一行数据加上 '排他锁' 后，其他事务不能再在其上加其他的锁。
 *                                  当前添加 '排他锁' 的事务可以读也能修改，但是其他的事务只能读取不能修改。
 *           MySql在Innodb存储引擎中，处于并发情况下，事务A在行数据添加 '排他锁' 后，事务B在事务A提交前执行一个普通SELECT语句(与事务A是同一数据行)，
 *           默认使用的事务隔离级别 '可重复读'，正常情况下会自动为事务B查询的行数据添加 '共享锁'，但是查询的数据行已经被事务A添加了 '排他锁'，
 *           因此 '排他锁' 会阻止事务B往同一行数据再添加 '共享锁'，这时候事务B的查询就变成了普通无锁查询.
 *
 *      [3]、意向锁(intention lock)：一种表级别锁，用于表明事务在获取更高级别锁之前判断是否已经持有其他锁。
 *                                  意向锁不会直接影响读写操作，而是用来对锁状态进行优化。
 *           只有innodb存储引擎下 '意向锁' 又分 '意向共享锁' 和 '意向排他锁'。
 *               意向共享锁：表示事务获取行 '共享锁' 时，必须先得获取该表的 '意向共享锁'；
 *               意向排他锁：表示事务获取行 '排他锁' 时，必须先得获取该表的 '意向排他锁'；
 *           如果要对整张表进行加锁，需保证该表内目前不存在任何锁。因此，如果需要对整个表加锁，那么可以先检查 '意向锁' 是否被占用，
 *           进而知道表内目前是否存在 '共享锁' 或 '排他锁' 了。而不需要再一行行地去检查行记录是否被加锁。
 *
 * 4、MySQL从锁的种类上分类
 *      [1]、乐观锁：是指操作数据库时(更新操作)，乐观认为这次操作不会导致冲突，在操作数据时并不进行任何其他的特殊处理（也就是不加锁）
 *                 而在进行更新后，再去判断是否有冲突了。乐观锁不是数据库自带的，需要我们自己去实现。
 *                 乐观锁的实现方式主要有两种：CAS机制和版本号机制
 *                                          支持并发，事务也不需要排队，只不过需要一个版本号。
 *                 1、通过添加一个版本号，在代码逻辑中判断更新操作返回值是否为1。更新失败则进行递归操作。
 *                    通过 乐观锁+自旋 的方式，解决数据更新的线程安全问题，而且锁粒度比互斥锁低，并发性能好。
 *                    版本号的方法并不是适用于所有的乐观锁场景。
 *                 2、条件过滤：举个例子，当电商抢购活动时，大量并发进入，如果仅仅使用版本号或者时间戳，
 *                            就会出现商品库存足够，用户查询库存也存在，但是却在扣减库存时失败了。且由于并发量高，导致大量扣减请求失败。
 *                            想象一下，版本号每次只会有一个用户:扣减成功，不可避免的人为造成失败。这种时候就需要我们的第二种场景的乐观锁方法
 *
 *                             update t_goods set num = num-#{buyNum} where id = #{id} and num-#{buyNum} >= 0 and status = 1；
 *                             num 表示产品库存
 *                             status 表示产品状态：1、在售；2、暂停出售。
 *
 *                             这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高。这种模式也是目前我用来锁产品库存的方法，十分方便实用。
 *                             注意：乐观锁的更新操作，最好用主键或者唯一索引来更新，这样是行锁，否则更新时会锁表。
 *      [2]、悲观锁：是指操作数据时，悲观认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作。
 *                 由悲观锁涉及到的另外两个锁概念：共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。
 */
public class P16_锁 {}
