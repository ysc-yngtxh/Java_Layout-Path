/**
 * @author 游家纨绔
 */
/* 1、什么是连接查询？
 *        在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是多张表联合查询去除最终的结果。
 *        在实际开发中，一般一个业务都会对应多张表，比如：学生和班级，起码两张表。
 *
 *          stu_no   stu_name   class_no    classname
 *        -------------------------------------------------
 *           1        zs           1      湖北省武汉市江夏区
 *           2        ls           1      湖北省武汉市江夏区
 *        学生和班级信息存储到一张表中，结果就像上面一样，数据会存在大量的重复，导致数据的冗(rong三声)余。
 * ---------------------------------------------------------------------------------------------------------------
 * 2、连接查询的分类
 *        根据语法出现的年代来划分的，包括：
 *           SQL92 (一些老的DBA可能还在使用这种语法。DBA: DataBase Administrator[数据管理员])
 *           SQL99 (比较新的语法)
 *           根据表的连接方式来划分：
 *                              内连接：没有左内连接和右内连接的语法
 *                                    等值连接
 *                                    非等值连接
 *                                    自连接
 *                              外连接：
 *                                    左外连接(左连接)left outer join = left join
 *                                    右外连接(右连接)right outer join = right join
 *                              全连接：(这个很少用不做了解)
 *                                     full join,在两张表进行连接查询时，返回左表和右表中所有没有匹配的行。
 * ---------------------------------------------------------------------------------------------------------------
 * 3、在表的连接查询方面有一种现象被称为：笛卡尔积现象。(笛卡尔乘积现象)
 *        案例一：找出每一个员工的部门名称，要求显示员工名和部门名
 *                          +-----------+-------------+
 *                          ｜ ename    ｜ dept_no    ｜
 *               emp表      +-----------+-------------+
 *                          ｜ SMITH    ｜ 20         ｜
 *                          ｜ JONES    ｜ 10         ｜
 *                          +-----------+-------------+
 *                          +-----------+-------------+-----------+
 *                          ｜ dept_no  ｜ d_name     ｜ loc       ｜
 *               dept表     +-----------+-------------+-----------｜
 *                          ｜ 10       ｜ ACCOUNTING ｜ NEW YORK  ｜
 *                          ｜ 40       ｜ OPERATIONS ｜ BOSTON    ｜
 *                          +-----------+-------------+-----------+
 *               SELECT e.ename, d.d_name FROM emp e, dept d;
 *               表别名的好处：第一：执行效率高(避免在两张表中查询到相同字段数据时，无法取出正确的需要的数据)。
 *                           第二：可读性好
 *
 *        笛卡尔积现象：当这两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积(2 X 2)
 *                    +-----------+-------------+
 *                    ｜ ename    ｜ d_name      ｜
 *                    +-----------+-------------+
 *                    ｜ SMITH    ｜ ACCOUNTING  ｜
 *                    ｜ SMITH    ｜ OPERATIONS  ｜
 *
 *                    ｜ JONES    ｜ ACCOUNTING  ｜
 *                    ｜ JONES    ｜ OPERATIONS  ｜
 *                    +-----------+-------------+
 *        怎么避免笛卡尔积现象？当然是加条件进行过滤
 *                    思考：避免了笛卡尔积现象，会减少记录的匹配次数吗？
 *                         不会，次数还是16次，只不过显示的是有效记录。
 *
 *        案例二：找出每一个员工的部门名称，要求显示员工名和部门名
 *               SELECT                       +-----------+-------------+
 *                  e.ename, d.d_name         ｜ ename    ｜ d_name      ｜
 *               FROM                         +-----------+-------------+   sql92语法，以后不用，作为了解
 *                  emp e, dept d             ｜ JONES    ｜ ACCOUNTING  ｜
 *               WHERE                        +-----------+-------------+
 *                  e.dept_no = d.dept_no;
 * ---------------------------------------------------------------------------------------------------------------
 * 4、内连接
 *        内连接：假设A和B表进行内连接的话，凡是A表和B表能够匹配上连接关系的记录都查询出来，这就是内连接。AB两张表没有主副之分，两张表是平等的
 *
 *        [1]、等值连接 最大特点是：条件是等量关系。
 *               案例：查询每个员工的部门名称，要求显示员工名和部门名 。
 *               SQL92：(太老了，不常用)
 *                      SELECT
 *                         e.ename, d.d_name
 *                      FROM
 *                         emp e,dept d
 *                      WHERE
 *                         e.dept-no = d.dept_no;
 *
 *               SQL99：(常用)                       语法：
 *                      SELECT                           SELECT
 *                         e.ename, d.d_name                 ...
 *                      FROM                             FROM
 *                         emp e                             A
 *                      JOIN                             INNER JOIN   // inner可以省略的，带着inner目的是可读性好一些
 *                         dept d                            B
 *                      ON                               ON
 *                         e.dept_no = d.dept_no;            连接条件
 *                                                       WHERE
 *                                                           ...
 *
 *        [2]、非等值连接 最大的特点是：连接条件中的关系是非等量关系
 *               案例：找出每个员工的工资等级，要求显示员工名、工资、工资等级
 *                          +-----------+--------------+
 *                          ｜ ename    ｜ sal         ｜   // 员工姓名  工资
 *               emp表       +-----------+-------------+
 *                          ｜ SMITH    ｜ 800.00      ｜
 *                          ｜ ALLEN    ｜ 3000.00     ｜
 *                          ｜ WARD     ｜ 2005.00     ｜
 *                          ｜ JONES    ｜ 1080.00     ｜
 *                          +-----------+--------------+
 *                          +-----------+-------------+-----------+
 *                          ｜ grade    ｜ loSal      ｜ hiSal     ｜  // 工资等级   员工最低金额   员工最高金额
 *                          +-----------+-------------+-----------+
 *               sal_grade表｜ 1        ｜ 700        ｜ 1200      ｜
 *                          ｜ 2        ｜ 1201       ｜ 1400      ｜
 *                          ｜ 3        ｜ 1401       ｜ 2000      ｜
 *                          ｜ 4        ｜ 2001       ｜ 3000      ｜
 *                          +-----------+-------------+-----------+
 *                SELECT
 *                   e.ename, e.sal, s.grade
 *                FROM
 *                   emp e
 *                INNER JOIN
 *                   sal_grade s
 *                ON
 *                   e.sal BETWEEN s.loSal AND s.hiSal;
 *
 *        [3]、自连接 最大特点是： 一张表看作两张表
 *               案例：找出每个员工的上级领导，要求显示员工名和对应的领导名
 *                       +-----------+-------------+-----------+
 *                       ｜ emp_no   ｜ ename       ｜ mgr      ｜   // 员工编号   员工名   员工的上级领导编号
 *                       +-----------+-------------+-----------｜
 *               emp表   ｜ 7839     ｜ KING        ｜ NULL     ｜
 *                       ｜ 4563     ｜ CLARK       ｜ 7263     ｜
 *                       ｜ 4135     ｜ FORD        ｜ 4563     ｜
 *                       ｜ 7263     ｜ WARD        ｜ 7839     ｜
 *                       +-----------+-------------+-----------｜
 *                SELECT
 *                   A.ename AS '员工', B.ename AS '员工上级领导'
 *                FROM
 *                   emp A
 *                INNER JOIN
 *                   emp B
 *                ON
 *                   A.mgr=B.emp_no;   // 这里无法查询出KING的上级领导，因为KING是大老板，没有上级领导，所以只有三组数据
 * ---------------------------------------------------------------------------------------------------------------
 * 5、外连接
 *       [1]、什么是外连接，和内连接有什么区别？
 *              外连接：假设A和B表进行连接，使用外连接的话，AB两张表中有一张表示主表，一张表是副表，主要查询主表中的数据，
 *                     捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出 null 与之匹配。
 *
 *              左外连接(左连接 LEFT OUTER)：表示左边的这张表是主表、
 *              右外连接(右连接 RIGHT OUTER)：表示右边的这张表是主表、
 *              左连接有右连接的写法，右连接也会有对应的左连接的写法
 *
 *       [2]、案例一：找出每个员工的上级领导
 *                   +-----------+----------+--------+
 *                   ｜ emp_no   ｜ ename   ｜ mgr    ｜   // 员工编号     员工名     员工的上级领导编号
 *                   +-----------+----------+--------｜
 *            emp表  ｜ 7839      ｜ KING    ｜ NULL  ｜
 *                   ｜ 4563      ｜ CLARK   ｜ 7263  ｜
 *                   ｜ 4135      ｜ FORD    ｜ 4563  ｜
 *                   ｜ 7263      ｜ WARD    ｜ 7839  ｜
 *                   +-----------+----------+--------｜
 *            SELECT
 *               A.ename '员工表', B.ename '领导表'
 *            FROM
 *               emp A
 *            LEFT OUTER JOIN       // outer可以省略，写上去可读性更高
 *               emp B
 *            ON
 *               A.mgr = B.emp_no;  // 加上left语句，就是将emp A表作为主表。所以KING也可以显示出来，emp B表作为副表，没有数据默认null
 *
 *
 *       [3]、案例二：找出哪个部门没有员工
 *                   +-----------+-------------+               +-----------+-------------+---------+
 *                   ｜ ename    ｜ dept_no    ｜               ｜ dept_no  ｜ d_name     ｜ loc     ｜
 *                   +-----------+-------------+               +-----------+-------------+---------+
 *            emp表  ｜ SMITH     ｜ 20        ｜               ｜ 10       ｜ ACCOUNTING ｜ NEW YORK｜
 *                   ｜ ALLEN     ｜ 30        ｜        dept表 ｜ 20       ｜ RESEARCH   ｜ DALLAS  ｜
 *                   ｜ WARD      ｜ 20        ｜               ｜ 30       ｜ SALES      ｜ CHICAGO ｜
 *                   ｜ JONES     ｜ 10        ｜               ｜ 40       ｜ OPERATIONS ｜ BOSTON  ｜
 *                   +-----------+-------------+               +-----------+-------------+---------+
 *            SELECT
 *               d.dept
 *            FROM
 *               emp e
 *            RIGHT OUTER JOIN
 *               dept d
 *            ON
 *               e.dept_no = d.dept_no
 *            WHERE
 *               e.name IS NULL;
 * ---------------------------------------------------------------------------------------------------------------
 * 6、TODO MySQL中的 left join *1 on *2 and *3 语句and后面不生效，而 inner join *1 on *2 and *3 语句and生效
 *        Ⅰ、在 LEFT JOIN 中，条件中的 AND 连接条件会影响连接的结果集。
 *           作为外连接，其作为主表的数据是一定存在的，不会受 and 条件影响,但是次表会受到 and 条件影响。
 *           [1]、t_dict表
 *                +----+-----------+---------------+--------------+----------+
 *                ｜ id｜ dict_name ｜ dict_code    ｜ description ｜ del_flag｜
 *                +----+-----------+---------------+--------------+----------+
 *                ｜ 1 ｜ 支付方式   ｜ PAY_METHOD   ｜ 支付方式      ｜       0 ｜
 *                ｜ 2 ｜ 订单状态   ｜ ORDER_STATUS ｜ 订单状态      ｜       0 ｜
 *                +----+-------- --+---------------+--------------+----------+
 *           [2]、t_dict_item表
 *                +----+---------+-----------------+----------------+---------------+
 *                ｜ id ｜dict_id｜ item_text      ｜ item_value     ｜ description  ｜
 *                +----+---------+-----------------+----------------+---------------+
 *                ｜ 1  ｜ 1     ｜ 支付宝           ｜ ZFB           ｜ 支付宝        ｜
 *                ｜ 2  ｜ 1     ｜ 微信             ｜ WX            ｜ 微信         ｜
 *                ｜ 3  ｜ 1     ｜ 银联             ｜ YL            ｜ 银联         ｜
 *                ｜ 4  ｜ 2     ｜ 待付款           ｜ WAIT_BUYER_PAY ｜ 待付款       ｜
 *                ｜ 5  ｜ 2     ｜ 交易成功         ｜ TRADE_SUCCESS  ｜ 交易成功      ｜
 *                ｜ 6  ｜ 2     ｜ 订单取消成功      ｜ CANCEL_SUCCESS ｜ 订单取消成功  ｜
 *                ｜ 7  ｜ 2     ｜ 退款成功         ｜ REFUD_SUCCESS  ｜ 退款成功      ｜
 *                ｜ 8  ｜ 2     ｜ 退款失败         ｜ REFUD_FAIL     ｜ 退款失败      ｜
 *                ｜ 9  ｜ 2     ｜ 订单已关闭       ｜ TRADE_CLOSED   ｜ 订单已关闭     ｜
 *                +----+---------+-----------------+----------------+---------------+
 *        Ⅱ、假设有 左表t_dict 和 右表t_dict_item，语句 FROM t_dict LEFT JOIN t_dict_item ON [condition1] AND [condition2]
 *           [1]、在没有 WHERE 条件的情况下，使用 LEFT JOIN 连接，左表(主表)数据一定是全部都有的，
 *                condition2 过滤的是右表(次表)数据，对于左表(主表)数据不产生影响。
 *                且右表过滤的数据在对应的左表关联的结果集中返回为 NULL 值。
 *           [2]、SELECT
 *               	 d.id, d.dict_name, d.dict_code,
 *               	 di.id AS di_id, di.dict_id, di.item_text, di.item_value, di.description
 *                FROM t_dict AS d
 *               	 LEFT JOIN t_dict_item AS di
 *               	 ON d.id = di.dict_id
 *               	 AND di.item_text = '支付宝'
 *                +----+--------------+--------------+-------+---------+-----------+------------+-------------+
 *                ｜ id｜ dict_name   ｜ dict_code    ｜ di_id｜ dict_id｜ item_text ｜ item_value｜ description｜
 *                +----+--------------+--------------+-------+---------+-----------+------------+-------------+
 *                ｜ 1 ｜ 支付方式     ｜ PAY_METHOD   ｜ 1    ｜ 1       ｜ 支付宝    ｜ ZFB       ｜ 支付宝       ｜
 *                ｜ 2 ｜ 订单状态     ｜ ORDER_STATUS ｜ NULL ｜ NULL    ｜ NULL     ｜ NULL      ｜ NULL        ｜
 *                +----+--------------+--------------+-------+---------+-----------+------------+-------------+
 *           [3]、SELECT
 *               	 d.id, d.dict_name, d.dict_code,
 *               	 di.id AS di_id, di.dict_id, di.item_text, di.item_value, di.description
 *                FROM t_dict AS d
 *               	 LEFT JOIN t_dict_item AS di
 *               	 ON d.id = di.dict_id
 *               	 AND d.dict_name='支付方式'
 *                分析：左表为主表，数据全都有。因此字段dict_name会显示"支付方式"、"订单状态"等。
 *                      而 d.dict_name='支付方式' 条件对于左表来说不受影响，但是会约束右表数据只能关联'支付方式'
 *                +----+--------------+--------------+-------+---------+-----------+------------+-------------+
 *                ｜ id｜ dict_name   ｜ dict_code    ｜ di_id｜ dict_id｜ item_text ｜ item_value｜ description｜
 *                +----+--------------+--------------+-------+---------+-----------+------------+-------------+
 *                ｜ 1 ｜ 支付方式     ｜ PAY_METHOD   ｜ 1    ｜ 1       ｜ 支付宝    ｜ ZFB       ｜ 支付宝       ｜
 *                ｜ 1 ｜ 支付方式     ｜ PAY_METHOD   ｜ 2    ｜ 1       ｜ 微信      ｜ WX        ｜ 微信        ｜
 *                ｜ 1 ｜ 支付方式     ｜ PAY_METHOD   ｜ 3    ｜ 1       ｜ 银联      ｜ YL        ｜ 银联        ｜
 *                ｜ 2 ｜ 订单状态     ｜ ORDER_STATUS ｜ NULL ｜ NULL    ｜ NULL     ｜ NULL      ｜ NULL        ｜
 *                +----+--------------+--------------+-------+---------+-----------+------------+-------------+
 *        Ⅲ、INNER JOIN 中，条件中 AND 连接条件只作用于连接的过程，不影响连接的结果集。如果 AND 条件不满足，对应的记录会被排除结果中。
 *               SELECT
 *               	d.id, d.dict_name, d.dict_code,
 *               	di.id AS di_id, di.dict_id, di.item_text, di.item_value, di.description
 *               FROM t_dict AS d
 *               	INNER JOIN t_dict_item AS di
 *               	ON d.id = di.dict_id
 *               	AND di.item_text = '支付宝'
 *               +----+--------------+--------------+-------+---------+-----------+------------+-------------+
 *               ｜ id｜ dict_name   ｜ dict_code   ｜ di_id ｜ dict_id｜ item_text ｜ item_value｜ description｜
 *               +----+--------------+--------------+-------+---------+-----------+------------+-------------+
 *               ｜ 1 ｜ 支付方式     ｜ PAY_METHOD   ｜ 1    ｜ 1       ｜ 支付宝    ｜ ZFB       ｜ 支付宝       ｜
 *               +----+--------------+--------------+-------+---------+-----------+------------+-------------+
 *        Ⅳ、总结来说：
 *           LEFT JOIN 中的 AND 连接条件会优先保留左表的记录，并根据条件从右表中匹配相应记录；不满足条件的左表产生 NULL 值。
 *           INNER JOIN 中的 AND 连接条件会从连接的结果中排除不满足条件的记录。
 *        Ⅴ、如果你实在想用 LEFT JOIN 的方式去过滤，应当把 AND 的条件书写在 WHERE 语句中
 *               SELECT
 *               	d.id, d.dict_name, d.dict_code,
 *               	di.id AS di_id, di.dict_id, di.item_text, di.item_value, di.description
 *               FROM t_dict AS d
 *               	LEFT JOIN t_dict_item AS di
 *               	ON d.id = di.dict_id
 *               WHERE
 *               	di.item_text = '支付宝'
 *               +----+--------------+--------------+-------+---------+-----------+------------+-------------+
 *               ｜ id｜ dict_name   ｜ dict_code   ｜ di_id ｜ dict_id｜ item_text ｜ item_value｜ description｜
 *               +----+--------------+--------------+-------+---------+-----------+------------+-------------+
 *               ｜ 1 ｜ 支付方式     ｜ PAY_METHOD   ｜ 1    ｜ 1       ｜ 支付宝    ｜ ZFB       ｜ 支付宝       ｜
 *               +----+--------------+--------------+-------+---------+-----------+------------+-------------+
 */
public class E5_1连接查询 {}
