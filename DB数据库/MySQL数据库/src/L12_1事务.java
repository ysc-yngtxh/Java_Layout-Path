/**
 * @author 游家纨绔
 */
/* 1、什么是事务？
 *        一个事务是一个完整的业务逻辑单元，不可再分。
 *
 *        比如：银行账户转账，从账户向账户转账10000，需要执行两条update语句
 *                 UPDATE t_act SET balance=balance-10000 WHERE act_no='act-001';
 *                 UPDATE t_act SET balance=balance+10000 WHERE act_no='act-002';
 *             以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败。
 *             要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的"事务机制"。
 * ---------------------------------------------------------------------------------------------------------------
 * 2、事务的特性
 *        事务包括四大特性：ACID
 *           A -- 原子性: 事务是最小的工作单元，不可再分。必须保证多条脚本语句同时成功或者同时失败
 *           C -- 一致性: 使数据库从一个一致性状态变换到另外一个一致性状态（当在高并发情况下，可能会出现数据不一致的结果。而事务则保证并发结束后数据也是一致的）
 *           I -- 隔离性: 多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事物之间要相互隔离。
 *           D -- 持久性: 持久性说的是最终数据必须持久化到硬盘中，事务才算成功的都结束。
 * ---------------------------------------------------------------------------------------------------------------
 * 3、MySQL事务是怎么实现的
 *     [1]、原子性：一个事务中的多个操作都是不可分割的，只能是全部执行成功、或者全部执行失败。
 *          MySQL事务的原子性是通过undo log来实现的。undo log是InnoDB存储引擎特有的。
 *          具体的实现方式是：将所有对数据的修改（增、删、改）都写入日志（undo log）。
 *                         如果一个事务中的一部分操作已经成功，但另一部分操作，由于断电/系统崩溃/其它的软硬件错误而无法成功执行，
 *                         则通过回溯日志，将已经执行成功的操作撤销，从而达到全部操作失败的目的。
 *
 *          undo log是逻辑日志：
 *                            记录和事务操作相反的SQL语句，事务执行insert语句，undo log就记录delete语句。
 *                            它以追加写的方式记录日志，不会覆盖之前的日志。
 *                            除此之外undo log还用来实现数据库多版本并发控制（MultiVersion Concurrency Control，简称MVCC）
 *
 *     [2]、持久性：一个事务对数据的所有修改，都会永久的保存在数据库中。
 *          MySQL事务的持久性是通过redo log来实现的。redo log也是InnoDB存储引擎特有的。
 *          具体实现方式是：
 *                      当发生数据修改（增、删、改）的时候，InnoDB引擎会先将记录写到redo log中，并更新内存，此时更新就算完成了。
 *                      同时InnoDB引擎会在合适的时机将记录刷到磁盘中。
 *
 *          redo log是物理日志：
 *                     记录的是在某个数据页做了什么修改，而不是SQL语句的形式。它有固定大小，是循环写的方式记录日志，空间用完后会覆盖之前的日志。
 * ---------------------------------------------------------------------------------------------------------------
 * 4、关于事务之间的隔离性（理论上隔离级别包括4个）
 *      第一级别：读未提交(read uncommitted)
 *              A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。
 *              读未提交存在脏读(Dirty Read)现象：表示读到了脏的数据。
 *
 *      第二级别：读已提交(read committed)
 *              [1]、大多数数据库使用默认隔离级别就是这个，比如 Oracle数据库（Mysql不是）-- RC隔离级别
 *                   读已提交存在的问题是：在多重并发情况下，同一个事务中不可重复读
 *              [2]、不可重复读 指的是在一个事务内，当多次读取同一数据行(并非指的是一行数据)时，读取的结果可能会发生变化。
 *                   这是因为在事务执行过程中，其他事务对该数据行进行了更新(update、delete)操作，导致读取到了不同的数值。
 *              [3]、不可重复读 举例 ---- 事务A执行两次读取数据的操作：
 *                   事务A第一次读取数据，比如读取了小明的年龄为20岁，此时事务B执行修改操作，将小明的年龄修改为30岁并且事务提交，
 *                   然后事务A第二次读取到小明的年龄时，发现其年龄是30岁，跟第一次读取数据不一样了，就会造成事务A的异常，程序回滚。
 *                   所以读已提交的数据是不可以重复的读取数据，这种隔离级别解决了：脏读现象没有了。
 *
 *      第三级别：可重复读(repeatable read)
 *              [1]、MySQL数据库‘默认’的隔离级别是：可重复读 -- RR隔离级别
 *                   这种隔离级别解决了：不可重复读问题     存在的问题是：读取到的数据有可能是虚幻的（幻读）
 *              [2]、可重复读 解决了不可重复读的问题，即在同一个事务中，多次读取同一数据行时，读取的结果始终保持一致。
 *                   它使用了共享锁（Shared Lock），即其他事务可以同时持有共享锁读取该数据行，但不能修改它，以确保读取的一致性。
 *                   ⚠️：①、在事务下的 SELECT语句 会自动为查询的行数据添加共享锁（读已提交级别下也能自动为普通SELECT语句添加共享锁）
 *                          涉及 INSERT、UPDATE、DELETE语句 会添加排他锁并阻止再添加其他锁；
 *                       ②、非事务下的 SELECT语句 没有任何锁机制。
 *              [3]、幻读 指的是在一个事务内，当多次执行同一个查询语句时，返回的结果集发生了变化。这是因为在事务执行过程中，
 *                   其他事务对相关数据进行了插入或删除操作(不可重复读是针对行级数据，幻读是针对表级数据)，导致查询结果发生了变化。
 *              [4]、幻读 举例 ---- 事务A执行两次统计数据总条数的操作：
 *                   事务A 第一次查询获取到数据总量，此时 事务B 执行新增（删除）数据的操作并提交，然后 事务A 进行第二次读取数据总条数，
 *                   但和第一次统计后得到的数据不一样，就像产生了幻觉一样，平白无故的多(少)了几条数据。前后数据不一致，并不会导致事务失败，
 *                   只是看到了不同的数据状态。这种现象也被称为成为 幻读。
 *              [5]、上述幻读例子可能会出现在 读未提交 和 读已提交 的事务隔离级别中，但是不会出现在 可重复读 里，可重复读避免了这种幻读情况，
 *                   但 可重复读 还存在其他的幻读情况。上述幻读例子在可重复读中，尽管B事务在A事务还未结束的时候，增加(减少)了表中的数据，
 *                   可是由于可重复读策略，A事务中不管怎么查询，始终都无法查询到新增的数据，因此前后两次查询的结果是一致的，从而避免幻读。
 *                   但是对于真实的表而言，表中的数据是的的确确增加了。
 *              [5]、小曹这时候又会问：为了维护可重复读，通过持有共享锁方式读取数据时不是不允许修改数据吗？怎么还能新增数据呢？
 *                   因为这个共享锁锁的是我们读取的数据行(行级锁)，读取这些数据行时是不允许进行修改的，但是又不是表级锁不影响往表中新增数据
 *              [6]、可重复读是如何避免幻读 ---- MVCC、 临键锁Next-Key Lock(记录锁+间隙锁)
 *                   MySQL InnoDB存储引擎很大程度上避免幻读现象，避免方案有两种，但都没有完全解决幻读问题。彻底解决幻读问题直接使用 '序列化读'。
 *                   ①、针对快照读(普通 SELECT语句)，是通过 MVCC（多版本并发控制）方式解决部分幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，
 *                      一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好的避免幻读问题。
 *                   ②、针对当前读(select ... for update 等语句)，是通过 临键锁Next-Key Lock（记录锁[Record Lock] + 间隙锁[Gap Lock]）方式解决了幻读，
 *                      因为当执行 select ... for update 语句的时候，会加上 临键锁Next-Key Lock，如果有其他事务在 Next-Key Lock临键锁 范围内插入了一条记录，
 *                      那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免部分幻读问题。
 *
 *      第四级别：序列化读/串行化读(serializable)
 *              [1]、通过事务的强制串行化执行，避免了幻读的问题，这个隔离级别会对读取的每一行数据加锁，可能导致大量的超时和锁征用的问题。
 *              [2]、实际上很少用这个隔离级别，只有在非常需要确保数据一致性的情况且没有并发的情况下才考虑使用这种方式。效率低，需要事务排队
 *
 *      总结：数据库的隔离级别：
 *           读未提交 -------------- 可能产生脏读，幻读，不可重复读
 *           读已提交(不可重复读) ---- 可能产生不可重复读，幻读
 *           可重复读 -------------- 可能产生幻读
 *           序列化 ---------------- 无
 *
 *           不可重复读：重点是修改。同样的条件，你读取过的数据，再次读取出来发现值不一样了，重点在更新操作。
 *           幻读：重点在于新增或者删除。同样的条件，第 1 次和第 2 次读出来的记录数不一样，重点在增删操作。
 *
 *                                                                +-----------------------+-----------------+
 *                                                                | Variable_name         | Value           |
 *     查看隔离级别：show variables like 'transaction_isolation';   +-----------------------+-----------------+
 *                                                                | transaction_isolation | REPEATABLE-READ |
 *                                                                +-----------------------+-----------------+
 * ---------------------------------------------------------------------------------------------------------------
 * 5、演示事务
 *     MySQL事务默认情况下是自动提交的（什么是自动提交？只要执行任意一条DML语句提交一次）怎么关闭自动提交？start transaction; 或 begin;
 *        像一些select、insert、update、delete等DQL、DML语句都是历史操作。
 *        并且每条语句执行完之后都会自动提交（auto_commit），提交到硬盘文件中。
 *
 *        提交事务语句：commit; 提交历史操作，并同步到硬盘文件中。
 *        回滚事务语句：rollback; 清空历史操作。
 *
 *        演示事务：
 *                DROP TABLE IF EXISTS t_user;
 *                CREATE TABLE t_user(
 *                   id INT PRIMARY KEY AUTO_INCREMENT,
 *                   username VARCHAR(255)
 *                );
 *                INSERT INTO t_user(username) VALUES('zs');
 *
 *                SELECT * FROM t_user;
 *                +----+----------+
 *                | id | username |
 *                +----+----------+
 *                |  1 | zs       |
 *                +----+----------+
 *                rollback;                // 回滚事务，清空历史操作。
 *                SELECT * FROM t_user;    // 这里为什么回滚之后还会显示历史操作呢？因为MySQL默认自动提交功能。
 *                +----+----------+
 *                | id | username |
 *                +----+----------+
 *                |  1 | zs       |
 *                +----+----------+
 *
 *                start transaction;        // 启动事务方式：①、start transaction; ②、begin;
 *                INSERT INTO t_user(username) VALUES('Lisi');
 *                INSERT INTO t_user(username) VALUES('WangWu');
 *                SELECT * FROM t_user;
 *                +----+----------+
 *                | id | username |
 *                +----+----------+
 *                |  1 | zs       |
 *                |  2 | Lisi     |
 *                |  3 | WangWu   |
 *                +----+----------+
 *                rollback;                 // 因为关闭了自动提交，所以以上的语句都属于历史操作，会被rollback回滚事务清空
 *                +----+----------+
 *                | id | username |
 *                +----+----------+
 *                |  1 | zs       |
 *                +----+----------+
 *                INSERT INTO t_user(username) VALUES('ZhaoLiu');
 *                INSERT INTO t_user(username) VALUES('ZhaoPi');
 *                commit;                   // 这里是提交事务，历史操作都被提交到硬盘文件中。
 *                SELECT * FROM t_user;
 *                +----+----------+
 *                | id | username |
 *                +----+----------+
 *                |  1 | zs       |
 *                |  4 | ZhaoLiu  |
 *                |  5 | ZhaoPi   |
 *                +----+----------+
 *                // 这里的id是自动增加的主键，因为'Lisi'、'WangWu'历史操作被回滚，所以没有2和3。属于auto_increment机制
 * ---------------------------------------------------------------------------------------------------------------
 * 6、使用两个事务演示隔离级别
 *         第一：读未提交(read uncommitted)
 *              设置事务的全局隔离级别：
 *                 set global transaction isolation level read uncommitted;
 *              查看事务的全局隔离级别：
 *                 select @@global.transaction_isolation;
 *
 *              其实就是在历史操作期间，还未被提交到硬盘文件就能被读到的意思
 *
 *          第二：读已提交(read committed)
 *               其实就是在历史操作期间，只有被提交到硬盘文件才能被读到的意思
 *
 *          第三：可重复读(repeatable read)
 *          第四：可串行化
 */
public class L12_1事务 {}
