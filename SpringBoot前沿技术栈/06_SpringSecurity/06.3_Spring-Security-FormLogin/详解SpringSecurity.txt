
一、入门案例认证流程
    接口:                                       实现类:
       AbstractAuthenticationProcessingFilter       UsernamePasswordAuthenticationFilter
           ⬇︎                                           ⬇︎
       AuthenticationManager                        ProviderManager
           ⬇︎                                           ⬇︎
       AuthenticationProvider                       DaoAuthenticationProvider
           ⬇︎                                           ⬇︎
       UserDetailsService                           InMemoryUserDetailsManager（JdbcUserDetailsManager）

    UsernamePasswordAuthenticationFilter
        |- attemptAuthentication()方法尝试认证
              |- UsernamePasswordAuthenticationToken包装用户信息
                    |- AuthenticationManager
                          |- authenticate()方法有一个for循环来执行 AuthenticationProvider
                                |- AuthenticationProvider
                                      |- authenticate()方法
                                            |- retrieveUser()方法检索用户名
                                                 |- UserDetailsService
                                                       |- loadUserByUsername()方法
                                            |- additionalAuthenticationChecks()方法检索密码

   表单登录的认证流程
   1、表单提交用户名、密码
   2、表单的请求被 UsernamePasswordAuthenticationFilter 捕获，调用 attemptAuthentication 方法执行响应
   3、将用户名和密码封装到 Authentication（实现类[UsernamePasswordAuthenticationToken]）对象之中。这时候只有用户名和密码，权限还没有。
   4、AuthenticationManager 是认证管理器，它通过 authenticate() 方法发起委托认证，之后由 ProviderManager 根据参数类型，匹配合适的 AuthenticationProvider
   5、AuthenticationProvider 是认证类的提供者，其实现类 DaoAuthenticationProvider 专用于处理 UsernamePasswordAuthenticationToken 的认证请求
   6、DaoAuthenticationProvider 认证类执行 authenticate() 方法，其内部执行以下操作：
      (1)、调用 retrieveUser() 方法实现对用户名的检索。
           retrieveUser()方法中调用 UserDetailsService类的 loadUserByUsername()返回 UserDetails 对象
           ①、UserDetailsService 是用户信息的业务类。
              Ⅰ、其实现类 InMemoryUserDetailsManager 专用于从内存中检索用户信息
              Ⅱ、另外，可自定义其实现类，从数据库中检索用户信息
           ②、UserDetailsService 的实现类功能：
              Ⅰ、根据用户名去查询对应的用户以及这个用户对应的权限信息，InMemoryUserDetailsManager 是在内存中查找，自定义实现类是在数据库中查找。
              Ⅱ、把对应的用户信息包括去权限信息封装成 UserDetails 对象返回
           ③、UserDetails 是用户信息接口，其实现类 User 封装了用户信息，包括用户名、密码、权限信息等。
      (2)、调用 additionalAuthenticationChecks() 方法实现对密码的检索，
           通过 PasswordEncoder 对比 UserDetails 中的密码和 Authentication 的密码是否正确。
      (3)、如果上述的用户名与密码检索都正确，就把 UserDetails 中的权限信息封装到 Authentication（实现类[UsernamePasswordAuthenticationToken]）对象中
   7、返回 Authentication 对象给实现类 UsernamePasswordAuthenticationFilter
      (1)、返回的 Authentication 对象就使用 SecurityContextHolder.getContext().setAuthentication() 方法
           存储到 SecurityContextHolder 对象中，供后续Security的Filter使用。其他过滤器会通过 SecurityContextHolder 来获取当前用户信息。


二、Spring Security的密码加密理解
    1、对应的用户信息包括去权限信息封装成 UserDetails 对象。
    2、通过 PasswordEncoder 对比 UserDetails 中的密码和 Authentication 中的密码是否一致，
      如果一致则放入 SecurityContextHolder中(密码是否过期、是否锁定等)
       ①、实际项目中我们不会把密码明文形式存放数据库。默认的 PasswordEncoder 要求数据库密码格式 {id}password ,它会根据id去判断加密方式。
           比如账号'You shicheng'的密码'{noop}123456'。而Authentication的密码是'123456',比对后登陆成功!
       ②、但我们一般不会使用这种方式，而是采用 SpringSecurity 为我们提供的 BCryPasswordEncoder 加密方式。
       ③、定义一个 SpringSecurity 配置类，加上@EnableWebSecurity注解,把 BCryPasswordEncoder 对象注入到Spring容器中，
          SpringSecurity就会使用该PasswordEncoder对象来进行密码校验。
    3、如果正确就把UserDetails中的权限信息设置到Authentication中。


三、CSRF攻击(跨域请求伪造 Cross-site request forgery)
        比如说，我们的有一个不是前后端分离的项目系统A，前后端都是通过Cookie或者JSESSIONID来校验用户信息的，
    有一天我通过这个A系统给自己的的女朋友转账（转账行为看成是C），转了大概有十个小目标。
    这个时候外部有一个钓鱼网站系统B，我在不知道是非法网站的的情况下点击了这个网站，
    这个网站就携带了我当前用户系统A的Cookie或者JSESSIONID去进行转账（也就是去操作C），然后转账成功了，
    因为发起转账请求的是自己的Cookie或者JSESSION，A系统验证了该用户身份信息（老铁没毛病）。
    其实就是因为 钓鱼网站系统B 伪造了我的请求，携带我的 Cookie 信息去进行访问而造成的。


        因此，为了避免这种攻击，Spring Security提供了防止CSRF攻击的手段。
    CSRF为了保证不是其他第三方网站访问，要求访问时携带参数名为 _csrf 值为token（token在服务端产生）的内容，
    如果token和服务端的token匹配成功，则正常访问。

    流程：
    1、当你在项目里开启了csrf(),那么不管你项目系统是否是前后端分离，SpringSecurity后端都会去生成一个 csrf_token 放入Cookie中，
       例如：XSRF-TOKEN=53efae5b-b0f9-4112-a328-3323a08d5ddc
    2、然后需要前端将这个 XSRF-TOKEN 值解析出来，后续的请求将 _csrf=解析的XSRF-TOKEN值 这个请求参数带上。
      （因为每次请求都会携带Cookie，为了防止是伪造的请求，所以后端不会从Cookie中解析这个csrf_token，只会从请求参数中解析_csrf）
    3、后端有过滤器进行校验，如果参数 _csrf 没有携带或者伪造就不允许访问。
    

        是不是觉得spring security的这个方式跟我们的Jwt很相似。不要怀疑，就是同一个原理
    只不过我们只在前后端分离项目中使用Jwt,所以我们在做前后端分离项目时候，就可以把csrf()关闭，
    前后端分离项目天生就预防了CSRF攻击

四、注销
     1、问题：
               我在页面的注销按钮提供一个 /logout 路径，但是整个项目我都没有去提供注销的逻辑接口，
            另外也没有在SpringSecurity中进行过注销的配置。那么这个路径究竟会指向何方呢？
     2、回答：
               如果自定义的前端登出接口是 /logout，那么就会使用SpringSecurity的内置接口 /logout
            内置接口则会执行 logoutUrl("/logout"); 清除HttpSession，Cookie，用户信息SecurityContextHolder 等。
            还会执行 logoutSuccessUrl("/toLoginForm?logout"); 这里的 /toLoginForm 路径会根据自己的设置的登录路径替换。
     3、参照：
           可依照默认SpringSecurity的 LogoutConfigurer 类，不进行注销功能配置，只需要把注销接口设置为 /logout

