<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">

    // TODO JS实现逻辑要求：以下两个延时函数。比如我想先延时1秒，在延迟2秒，再延时1秒，最后输出“完成”。

    const setDelay = (millisecond) => {
        return new Promise((resolve, reject) => {
            if (typeof millisecond != 'number') reject(new Error('参数必须是number类型'));
            setTimeout(() => {
                resolve(`我延迟了${millisecond}毫秒后输出的`)
            }, millisecond)
        })
    }
    const setDelaySecond = (seconds) => {
        return new Promise((resolve, reject) => {
            if (typeof seconds != 'number' || seconds > 10) reject(new Error('参数必须是number类型，并且小于等于10'));
            setTimeout(() => {
                resolve(`我延迟了${seconds}秒后输出的，注意单位是秒`)
            }, seconds * 1000)
        })
    }

    // 如果用then的写法，大概是这样（嵌套地狱写法出门右拐不送）：
    setDelay(1000)
        .then(result => {
            console.log(result);
            return setDelaySecond(2)
        })
        .then(result => {
            console.log(result);
            return setDelay(1000)
        })
        .then(result => {
            console.log(result);
            console.log('完成')
        })
        .catch(err => {
            console.log(err);
        })

    // 使用 async/await ，没有冗余的长长的链式代码，语义化也非常清楚，非常舒服
    const test = async () => {
        const result = await setDelay(1000);
        console.log(result);
        console.log(await setDelaySecond(2));
        console.log(await setDelay(1000));
        console.log('完成了');
    }

    // async函数中捕获错误除了catch()方法，可以使用try...catch语句
    const test = async () => {
        try {
            const result = await setDelay(1000);
            console.log(result);
            console.log(await setDelaySecond(2));
            console.log(await setDelay(1000));
            console.log('完成了');
        } catch (e) {
            console.log(e); // 这里捕获错误
        }
    }

    // 如果不想因为一个的错误就整个process都crash掉，可以拆分开分别处理
    const test = async () => {
        const result = await setDelay(1000).catch(err => {
            console.log(err)
        });
        console.log(result);
        const result1 = await setDelaySecond(12).catch(err => {
            console.log(err)
        })
        console.log(result1);
        console.log(await setDelay(1000));
        console.log('完成了');
    }

    // 改进一下，封装一下提取错误的代码函数
    function to(promise) {
        return promise.then(data => {
            return [null, data];
        }).catch(err => [err]); // es6的返回写法
    }

    const test = async () => {
        // es6的写法，返回一个数组，第一个是错误信息，第二个是then的异步返回数据
        [err, result] = await to(setDelay(1000))
        // 如果err存在就是有错，不想继续执行就抛出错误
        if (err) throw new Error('出现错误，同时我不想执行了');
        console.log(result);
        [err, result1] = await to(setDelaySecond(12))
        // 还想执行就不要抛出错误
        if (err) console.log('出现错误，同时我想继续执行', err);
        console.log(result1);
        console.log(await setDelay(1000));
        console.log('完成了');
    }


    // 期望的逻辑结果是：隔一秒输出 '我延迟了1000毫秒后输出的'，一共经过循环3次。
    const setDelay = (millisecond) => {
        return new Promise((resolve, reject) => {
            if (typeof millisecond != 'number') reject(new Error('参数必须是number类型'));
            setTimeout(() => {
                resolve(`我延迟了${millisecond}毫秒后输出的`)
            }, millisecond)
        })
    }

    // 结果输出是并行的！！！也就是说一秒钟一次性输出了3个值！
    // 分析：把setDelay(1000)这个直接添加到数组的时候，其实就已经执行了
    arr = [setDelay(1000), setDelay(1000), setDelay(1000)];
    arr[0]
        .then(result => {
            console.log(result)
            return arr[1]
        })
        .then(result => {
            console.log(result)
            return arr[2]
        })
        .then(result => {
            console.log(result)
        })

    // 解决方案：直接函数名存储函数的方式（不执行Promise）来达到目的
    arr = [setDelay, setDelay, setDelay]
    arr[0](1000)
        .then(result => {
            console.log(result)
            return arr[1](1000)
        })
        .then(result => {
            console.log(result)
            return arr[2](1000)
        })
        .then(result => {
            console.log(result)
        })

    // 上述写法是不优雅的，次数一多就GG了
    arr = [setDelay, setDelay, setDelay]
    let temp;
    temp = arr[0](1000)
    for (let i = 1; i <= arr.length; i++) {
        if (i === arr.length) {
            temp.then(result => {
                console.log('完成了');
            })
            break;
        }
        temp = temp.then((result) => {
            console.log(result);
            return arr[i - 1](1000)
        });
    }


    // 提取成公共方法。首先需要闭包Promise程序
    // 如果不闭包会导致什么后果呢？不闭包的话，你传入的参数值后，你的Promise会马上执行，导致状态改变，
    // 如果用闭包实现的话，你的Promise会一直保存着，等到你需要调用的时候再使用。
    function timeout(millisecond) {
        return () => {
            return setDelay(millisecond);
        }
    }

    arr = [timeout(2000), timeout(1000), timeout(1000)]
    const syncPromise = function (arr) {
        const _syncLoop = function (count) {
            if (count === arr.length - 1) { // 是最后一个就直接return
                return arr[count]()
            }
            return arr[count]().then((result) => {
                console.log(result);
                return _syncLoop(count + 1) // 递归调用数组下标
            });
        }
        return _syncLoop(0);
    }
    syncPromise(arr).then(result => {
        console.log(result);
        console.log('完成了');
    })
    // 或者 添加到Promise类中方法
    Promise.syncAll = function syncAll() {
        return syncPromise
    }
    // 以后可以直接使用
    Promise.syncAll(arr).then(result => {
        console.log(result);
        console.log('完成了');
    })


    // 大神写法
    const p = arr.reduce((total, current) => {
        return total.then((result) => {
            console.log(result);
            return current()
        })
    }, Promise.resolve('程序开始'))
    p.then((result) => {
        console.log('结束了', result);
    })

    // async/await写法
    let force = async () => {
        arr2 = [timeout(2000), timeout(1000), timeout(1000)]
        for (let i = 0; i < arr.length; i++) {
            let result = await arr[i]();
            console.log(result);
        }
    }
</script>
>
</body>
</html>